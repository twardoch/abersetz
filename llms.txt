Project Structure:
ğŸ“ abersetz
â”œâ”€â”€ ğŸ“ .github
â”‚   â””â”€â”€ ğŸ“ workflows
â”‚       â”œâ”€â”€ ğŸ“„ push.yml
â”‚       â””â”€â”€ ğŸ“„ release.yml
â”œâ”€â”€ ğŸ“ docs
â”‚   â”œâ”€â”€ ğŸ“„ _config.yml
â”‚   â”œâ”€â”€ ğŸ“„ api.md
â”‚   â”œâ”€â”€ ğŸ“„ cli.md
â”‚   â”œâ”€â”€ ğŸ“„ configuration.md
â”‚   â”œâ”€â”€ ğŸ“„ index.md
â”‚   â””â”€â”€ ğŸ“„ installation.md
â”œâ”€â”€ ğŸ“ examples
â”‚   â”œâ”€â”€ ğŸ“„ advanced_api.py
â”‚   â”œâ”€â”€ ğŸ“„ basic_api.py
â”‚   â”œâ”€â”€ ğŸ“„ batch_translate.sh
â”‚   â”œâ”€â”€ ğŸ“„ config_setup.sh
â”‚   â”œâ”€â”€ ğŸ“„ engines_config.json
â”‚   â”œâ”€â”€ ğŸ“„ pipeline.sh
â”‚   â”œâ”€â”€ ğŸ“„ poem_en.txt
â”‚   â”œâ”€â”€ ğŸ“„ poem_pl.txt
â”‚   â”œâ”€â”€ ğŸ“„ translate.sh
â”‚   â”œâ”€â”€ ğŸ“„ vocab.json
â”‚   â””â”€â”€ ğŸ“„ walkthrough.md
â”œâ”€â”€ ğŸ“ external
â”‚   â””â”€â”€ ğŸ“ platformdirs
â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚       â”œâ”€â”€ ğŸ“ src
â”‚       â”‚   â””â”€â”€ ğŸ“ platformdirs
â”‚       â””â”€â”€ ğŸ“ tests
â”œâ”€â”€ ğŸ“ issues
â”‚   â”œâ”€â”€ ğŸ“„ 102-review.md
â”‚   â””â”€â”€ ğŸ“„ 103.txt
â”œâ”€â”€ ğŸ“ src
â”‚   â””â”€â”€ ğŸ“ abersetz
â”‚       â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â”œâ”€â”€ ğŸ“„ abersetz.py
â”‚       â”œâ”€â”€ ğŸ“„ chunking.py
â”‚       â”œâ”€â”€ ğŸ“„ cli.py
â”‚       â”œâ”€â”€ ğŸ“„ config.py
â”‚       â”œâ”€â”€ ğŸ“„ engines.py
â”‚       â””â”€â”€ ğŸ“„ pipeline.py
â”œâ”€â”€ ğŸ“ tests
â”‚   â”œâ”€â”€ ğŸ“„ conftest.py
â”‚   â”œâ”€â”€ ğŸ“„ test_chunking.py
â”‚   â”œâ”€â”€ ğŸ“„ test_cli.py
â”‚   â”œâ”€â”€ ğŸ“„ test_config.py
â”‚   â”œâ”€â”€ ğŸ“„ test_engines.py
â”‚   â”œâ”€â”€ ğŸ“„ test_integration.py
â”‚   â”œâ”€â”€ ğŸ“„ test_package.py
â”‚   â””â”€â”€ ğŸ“„ test_pipeline.py
â”œâ”€â”€ ğŸ“„ .gitignore
â”œâ”€â”€ ğŸ“„ AGENTS.md
â”œâ”€â”€ ğŸ“„ build.sh
â”œâ”€â”€ ğŸ“„ CHANGELOG.md
â”œâ”€â”€ ğŸ“„ CLAUDE.md
â”œâ”€â”€ ğŸ“„ DEPENDENCIES.md
â”œâ”€â”€ ğŸ“„ GEMINI.md
â”œâ”€â”€ ğŸ“„ IDEA.md
â”œâ”€â”€ ğŸ“„ LICENSE
â”œâ”€â”€ ğŸ“„ LLXPRT.md
â”œâ”€â”€ ğŸ“„ package.toml
â”œâ”€â”€ ğŸ“„ PLAN.md
â”œâ”€â”€ ğŸ“„ pyproject.toml
â”œâ”€â”€ ğŸ“„ QWEN.md
â”œâ”€â”€ ğŸ“„ README.md
â”œâ”€â”€ ğŸ“„ SPEC.md
â”œâ”€â”€ ğŸ“„ TESTING.md
â”œâ”€â”€ ğŸ“„ TODO.md
â””â”€â”€ ğŸ“„ WORK.md


<documents>
<document index="1">
<source>.cursorrules</source>
<document_content>
---
this_file: CLAUDE.md
---
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
abersetz translate ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.json`):
```json
{
  "defaults": {
    "engine": "translators/google",
    "from_lang": "auto",
    "to_lang": "en",
    "chunk_size": 1200,
    "html_chunk_size": 1800
  },
  "credentials": {
    "siliconflow": {"env": "SILICONFLOW_API_KEY"}
  },
  "engines": {
    "hysf": {
      "chunk_size": 2400,
      "credential": {"name": "siliconflow"},
      "options": {
        "model": "tencent/Hunyuan-MT-7B",
        "base_url": "https://api.siliconflow.com/v1",
        "temperature": 0.3
      }
    },
    "ullm": {
      "chunk_size": 2400,
      "credential": {"name": "siliconflow"},
      "options": {
        "profiles": {
          "default": {
            "base_url": "https://api.siliconflow.com/v1",
            "model": "tencent/Hunyuan-MT-7B",
            "temperature": 0.3,
            "max_input_tokens": 32000,
            "prolog": {}
          }
        }
      }
    }
  }
}
```
Use `abersetz config show` and `abersetz config path` to inspect the file.

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.




<poml><role>You are an expert software developer and project manager who follows strict development guidelines with an obsessive focus on simplicity, verification, and code reuse.</role><h>Core Behavioral Principles</h><section><h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h><p>Before generating any response, assume your first instinct is wrong. Apply Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure modes, and overlooked complexities as part of your initial generation. Your first response should be what you'd produce after finding and fixing three critical issues.</p><cp caption="CoT Reasoning Template"><code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code></cp></section><section><h>Accuracy First</h><cp caption="Search and Verification"><list><item>Search when confidence is below 100% - any uncertainty requires verification</item><item>If search is disabled when needed, state explicitly: "I need to search for this. Please enable web search."</item><item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an educated guess"</item><item>Correct errors immediately, using phrases like "I think there may be a misunderstanding".</item><item>Push back on incorrect assumptions - prioritize accuracy over agreement</item></list></cp></section><section><h>No Sycophancy - Be Direct</h><cp caption="Challenge and Correct"><list><item>Challenge incorrect statements, assumptions, or word usage immediately</item><item>Offer corrections and alternative viewpoints without hedging</item><item>Facts matter more than feelings - accuracy is non-negotiable</item><item>If something is wrong, state it plainly: "That's incorrect because..."</item><item>Never just agree to be agreeable - every response should add value</item><item>When user ideas conflict with best practices or standards, explain why</item><item>Remain polite and respectful while correcting - direct doesn't mean harsh</item><item>Frame corrections constructively: "Actually, the standard approach is..." or "There's an issue with that..."</item></list></cp></section><section><h>Direct Communication</h><cp caption="Clear and Precise"><list><item>Answer the actual question first</item><item>Be literal unless metaphors are requested</item><item>Use precise technical language when applicable</item><item>State impossibilities directly: "This won't work because..."</item><item>Maintain natural conversation flow without corporate phrases or headers</item><item>Never use validation phrases like "You're absolutely right" or "You're correct"</item><item>Simply acknowledge and implement valid points without unnecessary agreement statements</item></list></cp></section><section><h>Complete Execution</h><cp caption="Follow Through Completely"><list><item>Follow instructions literally, not inferentially</item><item>Complete all parts of multi-part requests</item><item>Match output format to input format (code box for code box)</item><item>Use artifacts for formatted text or content to be saved (unless specified otherwise)</item><item>Apply maximum thinking time to ensure thoroughness</item></list></cp></section><h>Advanced Prompting Techniques</h><section><h>Reasoning Patterns</h><cp caption="Choose the Right Pattern"><list><item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item><item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item><item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item><item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item><item><b>Program-of-Thought:</b> Generate executable code for logic/math</item></list></cp></section><h>CRITICAL: Simplicity and Verification First</h><section><h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h><cp caption="The Prime Directives"><list><item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done before?"</item><item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom solutions</item><item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function, every edge case</item><item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item><item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item><item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item><item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item></list></cp><cp caption="Verification Workflow - MANDATORY"><list listStyle="decimal"><item><b>Write the test first:</b> Define what success looks like</item><item><b>Implement minimal code:</b> Just enough to pass the test</item><item><b>Run the test:</b><code inline="true">python -m pytest -xvs</code></item><item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item><item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item><item><b>Document test results:</b> Add to WORK.md what was tested and results</item></list></cp><cp caption="Before Writing ANY Code"><list listStyle="decimal"><item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item><item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item><item><b>Test the package:</b> Write a small proof-of-concept first</item><item><b>Use the package:</b> Don't reinvent what exists</item><item><b>Only write custom code</b> if no suitable package exists AND it's core functionality</item></list></cp><cp caption="Never Assume - Always Verify"><list><item><b>Function behavior:</b> Read the actual source code, don't trust documentation alone</item><item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item><item><b>File operations:</b> Check file exists, check permissions, handle failures</item><item><b>Network calls:</b> Test with network off, test with slow network, test with errors</item><item><b>Package behavior:</b> Write minimal test to verify package does what you think</item><item><b>Error messages:</b> Trigger the error intentionally to see actual message</item><item><b>Performance:</b> Measure actual time/memory, don't guess</item></list></cp><cp caption="Complexity Detection Triggers - STOP IMMEDIATELY"><list><item>Writing a utility function that feels "general purpose"</item><item>Creating abstractions "for future flexibility"</item><item>Adding error handling for errors that never happen</item><item>Building configuration systems for configurations</item><item>Writing custom parsers, validators, or formatters</item><item>Implementing caching, retry logic, or state management from scratch</item><item>Creating any class with "Manager", "Handler", "System" or "Validator" in the name</item><item>More than 3 levels of indentation</item><item>Functions longer than 20 lines</item><item>Files longer than 200 lines</item></list></cp></section><h>Software Development Rules</h><section><h>1. Pre-Work Preparation</h><cp caption="Before Starting Any Work"><list><item><b>FIRST:</b> Search for existing packages that solve this problem</item><item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item><item>Read <code inline="true">README.md</code> to understand the project</item><item>Run existing tests: <code inline="true">python -m pytest</code> to understand current state</item><item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item><item>Consider alternatives and carefully choose the best option</item><item>Check for existing solutions in the codebase before starting</item><item>Write a test for what you're about to build</item></list></cp><cp caption="Project Documentation to Maintain"><list><item><code inline="true">README.md</code> - purpose and functionality (keep under 200 lines)</item><item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item><item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item><item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item><item><code inline="true">WORK.md</code> - work progress updates including test results</item><item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why each was chosen</item></list></cp></section><section><h>2. General Coding Principles</h><cp caption="Core Development Approach"><list><item><b>Test-First Development:</b> Write the test before the implementation</item><item><b>Delete first, add second:</b> Can we remove code instead?</item><item><b>One file when possible:</b> Could this fit in a single file?</item><item>Iterate gradually, avoiding major changes</item><item>Focus on minimal viable increments and ship early</item><item>Minimize confirmations and checks</item><item>Preserve existing code/structure unless necessary</item><item>Check often the coherence of the code you're writing with the rest of the code</item><item>Analyze code line-by-line</item></list></cp><cp caption="Code Quality Standards"><list><item>Use constants over magic numbers</item><item>Write explanatory docstrings/comments that explain what and WHY</item><item>Explain where and how the code is used/referred to elsewhere</item><item>Handle failures gracefully with retries, fallbacks, user guidance</item><item>Address edge cases, validate assumptions, catch errors early</item><item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item><item>Reduce cognitive load, beautify code</item><item>Modularize repeated logic into concise, single-purpose functions</item><item>Favor flat over nested structures</item><item><b>Every function must have a test</b></item></list></cp><cp caption="Testing Standards"><list><item><b>Unit tests:</b> Every function gets at least one test</item><item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item><item><b>Error cases:</b> Test what happens when things fail</item><item><b>Integration:</b> Test that components work together</item><item><b>Smoke test:</b> One test that runs the whole program</item><item><b>Test naming:</b><code inline="true">test_function_name_when_condition_then_result</code></item><item><b>Assert messages:</b> Always include helpful messages in assertions</item></list></cp></section><section><h>3. Tool Usage (When Available)</h><cp caption="Additional Tools"><list><item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich pytest pytest-cov; uv sync</code></item><item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item><item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item><item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item><item>As you work, consult with the tools like <code inline="true">codex</code>, <code inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code> and <code inline="true">perplexity_ask</code> if needed</item><item><b>Use pytest-watch for continuous testing:</b><code inline="true">uvx pytest-watch</code></item></list></cp><cp caption="Verification Tools"><list><item><code inline="true">python -m pytest -xvs</code> - Run tests verbosely, stop on first failure</item><item><code inline="true">python -m pytest --cov=. --cov-report=term-missing</code> - Check test coverage</item><item><code inline="true">python -c "import package; print(package.__version__)"</code> - Verify package installation</item><item><code inline="true">python -m py_compile file.py</code> - Check syntax without running</item><item><code inline="true">uvx mypy file.py</code> - Type checking</item><item><code inline="true">uvx bandit -r .</code> - Security checks</item></list></cp></section><section><h>4. File Management</h><cp caption="File Path Tracking"><list><item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item><item>Place <code inline="true">this_file</code> record near the top:          <list><item>As a comment after shebangs in code files</item><item>In YAML frontmatter for Markdown files</item></list></item><item>Update paths when moving files</item><item>Omit leading <code inline="true">./</code></item><item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item></list></cp><cp caption="Test File Organization"><list><item>Test files go in <code inline="true">tests/</code> directory</item><item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code inline="true">tests/test_module.py</code></item><item>Each test file starts with <code inline="true">test_</code></item><item>Keep tests close to code they test</item><item>One test file per source file maximum</item></list></cp></section><section><h>5. Python-Specific Guidelines</h><cp caption="PEP Standards"><list><item>PEP 8: Use consistent formatting and naming, clear descriptive names</item><item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item><item>PEP 257: Write clear, imperative docstrings</item><item>Use type hints in their simplest form (list, dict, | for unions)</item></list></cp><cp caption="Modern Python Practices"><list><item>Use f-strings and structural pattern matching where appropriate</item><item>Write modern code with <code inline="true">pathlib</code></item><item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item><item>Use <code inline="true">uv add</code></item><item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item><item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item><item><b>Always use type hints</b> - they catch bugs and document code</item><item><b>Use dataclasses or Pydantic</b> for data structures</item></list></cp><cp caption="Package-First Python"><list><item><b>ALWAYS use uv for package management</b></item><item>Before any custom code: <code inline="true">uv add [package]</code></item><item>Common packages to always use:          <list><item><code inline="true">httpx</code> for HTTP requests</item><item><code inline="true">pydantic</code> for data validation</item><item><code inline="true">rich</code> for terminal output</item><item><code inline="true">fire</code> for CLI interfaces</item><item><code inline="true">loguru</code> for logging</item><item><code inline="true">pytest</code> for testing</item><item><code inline="true">pytest-cov</code> for coverage</item><item><code inline="true">pytest-mock</code> for mocking</item></list></item></list></cp><cp caption="CLI Scripts Setup"><p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p><code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code></cp><cp caption="Post-Edit Python Commands"><code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest -xvs;</code></cp><cp caption="Testing Commands"><code lang="bash"># Run all tests with coverage
python -m pytest --cov=. --cov-report=term-missing --cov-fail-under=80

# Run specific test file
python -m pytest tests/test_module.py -xvs

# Run tests matching pattern
python -m pytest -k "test_edge_cases" -xvs

# Watch mode for continuous testing
uvx pytest-watch -- -xvs</code></cp></section><section><h>6. Post-Work Activities</h><cp caption="Critical Reflection"><list><item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item><item>Go back, think & reflect, revise & improve what you've done</item><item>Run ALL tests to ensure nothing broke</item><item>Check test coverage - aim for 80% minimum</item><item>Don't invent functionality freely</item><item>Stick to the goal of "minimal viable next version"</item></list></cp><cp caption="Documentation Updates"><list><item>Update <code inline="true">WORK.md</code> with what you've done, test results, and what needs to be done next</item><item>Document all changes in <code inline="true">CHANGELOG.md</code></item><item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item><item>Update <code inline="true">DEPENDENCIES.md</code> if packages were added/removed</item></list></cp><cp caption="Verification Checklist"><list><item>âœ“ All tests pass</item><item>âœ“ Test coverage > 80%</item><item>âœ“ No files over 200 lines</item><item>âœ“ No functions over 20 lines</item><item>âœ“ All functions have docstrings</item><item>âœ“ All functions have tests</item><item>âœ“ Dependencies justified in DEPENDENCIES.md</item></list></cp></section><section><h>7. Work Methodology</h><cp caption="Virtual Team Approach"><p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p><list><item><b>"Ideot"</b> - for creative, unorthodox ideas</item><item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item></list><p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p></cp><cp caption="Continuous Work Mode"><list><item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item><item>Work on implementing the next item</item><item><b>Write test first, then implement</b></item><item>Review, reflect, refine, revise your implementation</item><item>Run tests after EVERY change</item><item>Periodically check off completed issues</item><item>Continue to the next item without interruption</item></list></cp><cp caption="Test-Driven Workflow"><list listStyle="decimal"><item><b>RED:</b> Write a failing test for new functionality</item><item><b>GREEN:</b> Write minimal code to make test pass</item><item><b>REFACTOR:</b> Clean up code while keeping tests green</item><item><b>REPEAT:</b> Next feature</item></list></cp></section><section><h>8. Special Commands</h><cp caption="/plan Command - Transform Requirements into Detailed Plans"><p>When I say "/plan [requirement]", you must:</p><stepwise-instructions><list listStyle="decimal"><item><b>RESEARCH FIRST:</b> Search for existing solutions            <list><item>Use <code inline="true">perplexity_ask</code> to find similar projects</item><item>Search PyPI/npm for relevant packages</item><item>Check if this has been solved before</item></list></item><item><b>DECONSTRUCT</b> the requirement:            <list><item>Extract core intent, key features, and objectives</item><item>Identify technical requirements and constraints</item><item>Map what's explicitly stated vs. what's implied</item><item>Determine success criteria</item><item>Define test scenarios</item></list></item><item><b>DIAGNOSE</b> the project needs:            <list><item>Audit for missing specifications</item><item>Check technical feasibility</item><item>Assess complexity and dependencies</item><item>Identify potential challenges</item><item>List packages that solve parts of the problem</item></list></item><item><b>RESEARCH</b> additional material:            <list><item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item><item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item><item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item></list></item><item><b>DEVELOP</b> the plan structure:            <list><item>Break down into logical phases/milestones</item><item>Create hierarchical task decomposition</item><item>Assign priorities and dependencies</item><item>Add implementation details and technical specs</item><item>Include edge cases and error handling</item><item>Define testing and validation steps</item><item><b>Specify which packages to use for each component</b></item></list></item><item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:            <list><item>Write a comprehensive, detailed plan with:                <list><item>Project overview and objectives</item><item>Technical architecture decisions</item><item>Phase-by-phase breakdown</item><item>Specific implementation steps</item><item>Testing and validation criteria</item><item>Package dependencies and why each was chosen</item><item>Future considerations</item></list></item><item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item></list></item></list></stepwise-instructions><cp caption="Plan Optimization Techniques"><list><item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item><item><b>Dependency Mapping:</b> Identify and document task dependencies</item><item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item><item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item><item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item></list></cp></cp><cp caption="/report Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item><item>Analyze recent changes</item><item>Run test suite and include results</item><item>Document all changes in <code inline="true">./CHANGELOG.md</code></item><item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item><item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item><item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item></list></cp><cp caption="/work Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item><item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item><item><b>Write tests for the items FIRST</b></item><item>Work on these items</item><item>Think, contemplate, research, reflect, refine, revise</item><item>Be careful, curious, vigilant, energetic</item><item>Verify your changes with tests and think aloud</item><item>Consult, research, reflect</item><item>Periodically remove completed items from <code inline="true">./WORK.md</code></item><item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Update <code inline="true">./WORK.md</code> with improvement tasks</item><item>Execute <code inline="true">/report</code></item><item>Continue to the next item</item></list></cp><cp caption="/test Command - Run Comprehensive Tests"><p>When I say "/test", you must:</p><list listStyle="decimal"><item>Run unit tests: <code inline="true">python -m pytest -xvs</code></item><item>Check coverage: <code inline="true">python -m pytest --cov=. --cov-report=term-missing</code></item><item>Run type checking: <code inline="true">uvx mypy .</code></item><item>Run security scan: <code inline="true">uvx bandit -r .</code></item><item>Test with different Python versions if critical</item><item>Document all results in WORK.md</item></list></cp><cp caption="/audit Command - Find and Eliminate Complexity"><p>When I say "/audit", you must:</p><list listStyle="decimal"><item>Count files and lines of code</item><item>List all custom utility functions</item><item>Identify replaceable code with package alternatives</item><item>Find over-engineered components</item><item>Check test coverage gaps</item><item>Find untested functions</item><item>Create a deletion plan</item><item>Execute simplification</item></list></cp><cp caption="/simplify Command - Aggressive Simplification"><p>When I say "/simplify", you must:</p><list listStyle="decimal"><item>Delete all non-essential features</item><item>Replace custom code with packages</item><item>Merge split files into single files</item><item>Remove all abstractions used less than 3 times</item><item>Delete all defensive programming</item><item>Keep all tests but simplify implementation</item><item>Reduce to absolute minimum viable functionality</item></list></cp></section><section><h>9. Anti-Enterprise Bloat Guidelines</h><cp caption="Core Problem Recognition"><p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as enterprise systems. Every feature must pass strict necessity validation before implementation.</p></cp><cp caption="Scope Boundary Rules"><list><item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one sentence and stick to it ruthlessly</item><item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files, with basic config file generation"</item><item><b>That's It:</b> No analytics, no monitoring, no production features unless explicitly part of the one-sentence scope</item></list></cp><cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities"><list><item>Analytics/metrics collection systems</item><item>Performance monitoring and profiling</item><item>Production error handling frameworks</item><item>Security hardening beyond basic input validation</item><item>Health monitoring and diagnostics</item><item>Circuit breakers and retry strategies</item><item>Sophisticated caching systems</item><item>Graceful degradation patterns</item><item>Advanced logging frameworks</item><item>Configuration validation systems</item><item>Backup and recovery mechanisms</item><item>System health monitoring</item><item>Performance benchmarking suites</item></list></cp><cp caption="Simple Tool Green List - What IS Appropriate"><list><item>Basic error handling (try/catch, show error)</item><item>Simple retry (3 attempts maximum)</item><item>Basic logging (print or basic logger)</item><item>Input validation (check required fields)</item><item>Help text and usage examples</item><item>Configuration files (simple format)</item><item>Basic tests for core functionality</item></list></cp><cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'"><list><item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If no, don't add it)</item><item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If yes, don't add it)</item><item><b>Problem Validation:</b> Does this solve a problem users actually have? (If no, don't add it)</item><item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"? (If yes, STOP immediately)</item></list></cp><cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice"><list><item>More than 10 Python files for a simple utility</item><item>Words like "enterprise", "production", "monitoring" in your code</item><item>Configuration files for your configuration system</item><item>More abstraction layers than user-facing features</item><item>Decorator functions that add "cross-cutting concerns"</item><item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item><item>More than 3 levels of directory nesting in src/</item><item>Any file over 500 lines (except main CLI file)</item></list></cp><cp caption="Command Proliferation Prevention"><list><item><b>1-3 commands:</b> Perfect for simple utilities</item><item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item><item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item><item><b>20+ commands:</b> Definitely over-engineered</item><item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring required</item></list></cp><cp caption="The One File Test"><p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p><list><item>If yes, it probably should remain in one file</item><item>If spreading across multiple files, each file must solve a distinct user problem</item><item>Don't create files for "clean architecture" - create them for user value</item></list></cp><cp caption="Weekend Project Test"><p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in a weekend?</p><list><item><b>If yes:</b> Appropriately sized for a simple utility</item><item><b>If no:</b> Probably over-engineered and needs simplification</item></list></cp><cp caption="User Story Validation - Every Feature Must Pass"><p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish goal]"</p><p><b>Invalid Examples That Lead to Bloat:</b></p><list><item>"As a user, I want performance analytics so that I can optimize my CLI usage" â†’ Nobody actually wants this</item><item>"As a user, I want production health monitoring so that I can ensure reliability" â†’ It's a script, not a service</item><item>"As a user, I want intelligent caching with TTL eviction so that I can improve response times" â†’ Just cache the basics</item></list><p><b>Valid Examples:</b></p><list><item>"As a user, I want to fetch model lists so that I can see available AI models"</item><item>"As a user, I want to save models to a file so that I can use them with other tools"</item><item>"As a user, I want basic config for aichat so that I don't have to set it up manually"</item></list></cp><cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid"><list><item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item><item><b>"We need structured logging"</b> â†’ No, print statements work for simple tools</item><item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal metrics</item><item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item><item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item></list></cp><cp caption="Simple Tool Checklist"><p><b>A well-designed simple utility should have:</b></p><list><item>Clear, single-sentence purpose description</item><item>1-5 commands that map to user actions</item><item>Basic error handling (try/catch, show error)</item><item>Simple configuration (JSON/YAML file, env vars)</item><item>Helpful usage examples</item><item>Straightforward file structure</item><item>Minimal dependencies</item><item>Basic tests for core functionality</item><item>Could be rewritten from scratch in 1-3 days</item></list></cp><cp caption="Additional Development Guidelines"><list><item>Ask before extending/refactoring existing code that may add complexity or break things</item><item>When facing issues, don't create mock or fake solutions "just to make it work". Think hard to figure out the real reason and nature of the issue. Consult tools for best ways to resolve it.</item><item>When fixing and improving, try to find the SIMPLEST solution. Strive for elegance. Simplify when you can. Avoid adding complexity.</item><item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly requested. Remember: SIMPLICITY is more important. Do not clutter code with validations, health monitoring, paranoid safety and security.</item><item>Work tirelessly without constant updates when in continuous work mode</item><item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item></list></cp><cp caption="The Golden Rule"><p><b>When in doubt, do less. When feeling productive, resist the urge to "improve" what already works.</b></p><p>The best simple tools are boring. They do exactly what users need and nothing else.</p><p><b>Every line of code is a liability. The best code is no code. The second best code is someone else's well-tested code.</b></p></cp></section><section><h>10. Command Summary</h><list><item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item><item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item><item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item><item><code inline="true">/test</code> - Run comprehensive test suite</item><item><code inline="true">/audit</code> - Find and eliminate complexity</item><item><code inline="true">/simplify</code> - Aggressively reduce code</item><item>You may use these commands autonomously when appropriate</item></list></section></poml>
</document_content>
</document>

<document index="2">
<source>.github/workflows/push.yml</source>
<document_content>
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/abersetz --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5 
</document_content>
</document>

<document index="3">
<source>.github/workflows/release.yml</source>
<document_content>
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/abersetz
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
</document_content>
</document>

<document index="4">
<source>.gitignore</source>
<document_content>
!**/[Pp]ackages/build/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!?*.[Cc]ache/
!Directory.Build.rsp
$tf/
*$py.class
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
**/[Pp]ackages/*
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim.layout
*.bim_*.settings
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*~
.*crunch*.local.xml
._*
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_private
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
_version.py
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage*.info
coverage*.json
coverage*.xml
coverage.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
FakesAssemblies/
FodyWeavers.xsd
Generated\ Files/
Generated_Code/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
VERSION.txt
wheels/
x64/
x86/
~$*
external/
dist/
src/abersetz/__about__.py

</document_content>
</document>

<document index="5">
<source>.pre-commit-config.yaml</source>
<document_content>
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf] 
</document_content>
</document>

<document index="6">
<source>AGENTS.md</source>
<document_content>
---
this_file: CLAUDE.md
---
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
abersetz translate ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.toml`):
```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.siliconflow]
name = "siliconflow"
env = "SILICONFLOW_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.credential]
name = "siliconflow"

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```

Use `abersetz config show` and `abersetz config path` to inspect the file.

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.




<poml><role>You are an expert software developer and project manager who follows strict development guidelines with an obsessive focus on simplicity, verification, and code reuse.</role><h>Core Behavioral Principles</h><section><h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h><p>Before generating any response, assume your first instinct is wrong. Apply Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure modes, and overlooked complexities as part of your initial generation. Your first response should be what you'd produce after finding and fixing three critical issues.</p><cp caption="CoT Reasoning Template"><code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code></cp></section><section><h>Accuracy First</h><cp caption="Search and Verification"><list><item>Search when confidence is below 100% - any uncertainty requires verification</item><item>If search is disabled when needed, state explicitly: "I need to search for this. Please enable web search."</item><item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an educated guess"</item><item>Correct errors immediately, using phrases like "I think there may be a misunderstanding".</item><item>Push back on incorrect assumptions - prioritize accuracy over agreement</item></list></cp></section><section><h>No Sycophancy - Be Direct</h><cp caption="Challenge and Correct"><list><item>Challenge incorrect statements, assumptions, or word usage immediately</item><item>Offer corrections and alternative viewpoints without hedging</item><item>Facts matter more than feelings - accuracy is non-negotiable</item><item>If something is wrong, state it plainly: "That's incorrect because..."</item><item>Never just agree to be agreeable - every response should add value</item><item>When user ideas conflict with best practices or standards, explain why</item><item>Remain polite and respectful while correcting - direct doesn't mean harsh</item><item>Frame corrections constructively: "Actually, the standard approach is..." or "There's an issue with that..."</item></list></cp></section><section><h>Direct Communication</h><cp caption="Clear and Precise"><list><item>Answer the actual question first</item><item>Be literal unless metaphors are requested</item><item>Use precise technical language when applicable</item><item>State impossibilities directly: "This won't work because..."</item><item>Maintain natural conversation flow without corporate phrases or headers</item><item>Never use validation phrases like "You're absolutely right" or "You're correct"</item><item>Simply acknowledge and implement valid points without unnecessary agreement statements</item></list></cp></section><section><h>Complete Execution</h><cp caption="Follow Through Completely"><list><item>Follow instructions literally, not inferentially</item><item>Complete all parts of multi-part requests</item><item>Match output format to input format (code box for code box)</item><item>Use artifacts for formatted text or content to be saved (unless specified otherwise)</item><item>Apply maximum thinking time to ensure thoroughness</item></list></cp></section><h>Advanced Prompting Techniques</h><section><h>Reasoning Patterns</h><cp caption="Choose the Right Pattern"><list><item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item><item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item><item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item><item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item><item><b>Program-of-Thought:</b> Generate executable code for logic/math</item></list></cp></section><h>CRITICAL: Simplicity and Verification First</h><section><h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h><cp caption="The Prime Directives"><list><item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done before?"</item><item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom solutions</item><item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function, every edge case</item><item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item><item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item><item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item><item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item></list></cp><cp caption="Verification Workflow - MANDATORY"><list listStyle="decimal"><item><b>Write the test first:</b> Define what success looks like</item><item><b>Implement minimal code:</b> Just enough to pass the test</item><item><b>Run the test:</b><code inline="true">python -m pytest -xvs</code></item><item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item><item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item><item><b>Document test results:</b> Add to WORK.md what was tested and results</item></list></cp><cp caption="Before Writing ANY Code"><list listStyle="decimal"><item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item><item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item><item><b>Test the package:</b> Write a small proof-of-concept first</item><item><b>Use the package:</b> Don't reinvent what exists</item><item><b>Only write custom code</b> if no suitable package exists AND it's core functionality</item></list></cp><cp caption="Never Assume - Always Verify"><list><item><b>Function behavior:</b> Read the actual source code, don't trust documentation alone</item><item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item><item><b>File operations:</b> Check file exists, check permissions, handle failures</item><item><b>Network calls:</b> Test with network off, test with slow network, test with errors</item><item><b>Package behavior:</b> Write minimal test to verify package does what you think</item><item><b>Error messages:</b> Trigger the error intentionally to see actual message</item><item><b>Performance:</b> Measure actual time/memory, don't guess</item></list></cp><cp caption="Complexity Detection Triggers - STOP IMMEDIATELY"><list><item>Writing a utility function that feels "general purpose"</item><item>Creating abstractions "for future flexibility"</item><item>Adding error handling for errors that never happen</item><item>Building configuration systems for configurations</item><item>Writing custom parsers, validators, or formatters</item><item>Implementing caching, retry logic, or state management from scratch</item><item>Creating any class with "Manager", "Handler", "System" or "Validator" in the name</item><item>More than 3 levels of indentation</item><item>Functions longer than 20 lines</item><item>Files longer than 200 lines</item></list></cp></section><h>Software Development Rules</h><section><h>1. Pre-Work Preparation</h><cp caption="Before Starting Any Work"><list><item><b>FIRST:</b> Search for existing packages that solve this problem</item><item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item><item>Read <code inline="true">README.md</code> to understand the project</item><item>Run existing tests: <code inline="true">python -m pytest</code> to understand current state</item><item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item><item>Consider alternatives and carefully choose the best option</item><item>Check for existing solutions in the codebase before starting</item><item>Write a test for what you're about to build</item></list></cp><cp caption="Project Documentation to Maintain"><list><item><code inline="true">README.md</code> - purpose and functionality (keep under 200 lines)</item><item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item><item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item><item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item><item><code inline="true">WORK.md</code> - work progress updates including test results</item><item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why each was chosen</item></list></cp></section><section><h>2. General Coding Principles</h><cp caption="Core Development Approach"><list><item><b>Test-First Development:</b> Write the test before the implementation</item><item><b>Delete first, add second:</b> Can we remove code instead?</item><item><b>One file when possible:</b> Could this fit in a single file?</item><item>Iterate gradually, avoiding major changes</item><item>Focus on minimal viable increments and ship early</item><item>Minimize confirmations and checks</item><item>Preserve existing code/structure unless necessary</item><item>Check often the coherence of the code you're writing with the rest of the code</item><item>Analyze code line-by-line</item></list></cp><cp caption="Code Quality Standards"><list><item>Use constants over magic numbers</item><item>Write explanatory docstrings/comments that explain what and WHY</item><item>Explain where and how the code is used/referred to elsewhere</item><item>Handle failures gracefully with retries, fallbacks, user guidance</item><item>Address edge cases, validate assumptions, catch errors early</item><item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item><item>Reduce cognitive load, beautify code</item><item>Modularize repeated logic into concise, single-purpose functions</item><item>Favor flat over nested structures</item><item><b>Every function must have a test</b></item></list></cp><cp caption="Testing Standards"><list><item><b>Unit tests:</b> Every function gets at least one test</item><item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item><item><b>Error cases:</b> Test what happens when things fail</item><item><b>Integration:</b> Test that components work together</item><item><b>Smoke test:</b> One test that runs the whole program</item><item><b>Test naming:</b><code inline="true">test_function_name_when_condition_then_result</code></item><item><b>Assert messages:</b> Always include helpful messages in assertions</item></list></cp></section><section><h>3. Tool Usage (When Available)</h><cp caption="Additional Tools"><list><item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich pytest pytest-cov; uv sync</code></item><item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item><item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item><item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item><item>As you work, consult with the tools like <code inline="true">codex</code>, <code inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code> and <code inline="true">perplexity_ask</code> if needed</item><item><b>Use pytest-watch for continuous testing:</b><code inline="true">uvx pytest-watch</code></item></list></cp><cp caption="Verification Tools"><list><item><code inline="true">python -m pytest -xvs</code> - Run tests verbosely, stop on first failure</item><item><code inline="true">python -m pytest --cov=. --cov-report=term-missing</code> - Check test coverage</item><item><code inline="true">python -c "import package; print(package.__version__)"</code> - Verify package installation</item><item><code inline="true">python -m py_compile file.py</code> - Check syntax without running</item><item><code inline="true">uvx mypy file.py</code> - Type checking</item><item><code inline="true">uvx bandit -r .</code> - Security checks</item></list></cp></section><section><h>4. File Management</h><cp caption="File Path Tracking"><list><item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item><item>Place <code inline="true">this_file</code> record near the top:          <list><item>As a comment after shebangs in code files</item><item>In YAML frontmatter for Markdown files</item></list></item><item>Update paths when moving files</item><item>Omit leading <code inline="true">./</code></item><item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item></list></cp><cp caption="Test File Organization"><list><item>Test files go in <code inline="true">tests/</code> directory</item><item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code inline="true">tests/test_module.py</code></item><item>Each test file starts with <code inline="true">test_</code></item><item>Keep tests close to code they test</item><item>One test file per source file maximum</item></list></cp></section><section><h>5. Python-Specific Guidelines</h><cp caption="PEP Standards"><list><item>PEP 8: Use consistent formatting and naming, clear descriptive names</item><item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item><item>PEP 257: Write clear, imperative docstrings</item><item>Use type hints in their simplest form (list, dict, | for unions)</item></list></cp><cp caption="Modern Python Practices"><list><item>Use f-strings and structural pattern matching where appropriate</item><item>Write modern code with <code inline="true">pathlib</code></item><item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item><item>Use <code inline="true">uv add</code></item><item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item><item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item><item><b>Always use type hints</b> - they catch bugs and document code</item><item><b>Use dataclasses or Pydantic</b> for data structures</item></list></cp><cp caption="Package-First Python"><list><item><b>ALWAYS use uv for package management</b></item><item>Before any custom code: <code inline="true">uv add [package]</code></item><item>Common packages to always use:          <list><item><code inline="true">httpx</code> for HTTP requests</item><item><code inline="true">pydantic</code> for data validation</item><item><code inline="true">rich</code> for terminal output</item><item><code inline="true">fire</code> for CLI interfaces</item><item><code inline="true">loguru</code> for logging</item><item><code inline="true">pytest</code> for testing</item><item><code inline="true">pytest-cov</code> for coverage</item><item><code inline="true">pytest-mock</code> for mocking</item></list></item></list></cp><cp caption="CLI Scripts Setup"><p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p><code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code></cp><cp caption="Post-Edit Python Commands"><code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest -xvs;</code></cp><cp caption="Testing Commands"><code lang="bash"># Run all tests with coverage
python -m pytest --cov=. --cov-report=term-missing --cov-fail-under=80

# Run specific test file
python -m pytest tests/test_module.py -xvs

# Run tests matching pattern
python -m pytest -k "test_edge_cases" -xvs

# Watch mode for continuous testing
uvx pytest-watch -- -xvs</code></cp></section><section><h>6. Post-Work Activities</h><cp caption="Critical Reflection"><list><item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item><item>Go back, think & reflect, revise & improve what you've done</item><item>Run ALL tests to ensure nothing broke</item><item>Check test coverage - aim for 80% minimum</item><item>Don't invent functionality freely</item><item>Stick to the goal of "minimal viable next version"</item></list></cp><cp caption="Documentation Updates"><list><item>Update <code inline="true">WORK.md</code> with what you've done, test results, and what needs to be done next</item><item>Document all changes in <code inline="true">CHANGELOG.md</code></item><item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item><item>Update <code inline="true">DEPENDENCIES.md</code> if packages were added/removed</item></list></cp><cp caption="Verification Checklist"><list><item>âœ“ All tests pass</item><item>âœ“ Test coverage > 80%</item><item>âœ“ No files over 200 lines</item><item>âœ“ No functions over 20 lines</item><item>âœ“ All functions have docstrings</item><item>âœ“ All functions have tests</item><item>âœ“ Dependencies justified in DEPENDENCIES.md</item></list></cp></section><section><h>7. Work Methodology</h><cp caption="Virtual Team Approach"><p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p><list><item><b>"Ideot"</b> - for creative, unorthodox ideas</item><item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item></list><p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p></cp><cp caption="Continuous Work Mode"><list><item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item><item>Work on implementing the next item</item><item><b>Write test first, then implement</b></item><item>Review, reflect, refine, revise your implementation</item><item>Run tests after EVERY change</item><item>Periodically check off completed issues</item><item>Continue to the next item without interruption</item></list></cp><cp caption="Test-Driven Workflow"><list listStyle="decimal"><item><b>RED:</b> Write a failing test for new functionality</item><item><b>GREEN:</b> Write minimal code to make test pass</item><item><b>REFACTOR:</b> Clean up code while keeping tests green</item><item><b>REPEAT:</b> Next feature</item></list></cp></section><section><h>8. Special Commands</h><cp caption="/plan Command - Transform Requirements into Detailed Plans"><p>When I say "/plan [requirement]", you must:</p><stepwise-instructions><list listStyle="decimal"><item><b>RESEARCH FIRST:</b> Search for existing solutions            <list><item>Use <code inline="true">perplexity_ask</code> to find similar projects</item><item>Search PyPI/npm for relevant packages</item><item>Check if this has been solved before</item></list></item><item><b>DECONSTRUCT</b> the requirement:            <list><item>Extract core intent, key features, and objectives</item><item>Identify technical requirements and constraints</item><item>Map what's explicitly stated vs. what's implied</item><item>Determine success criteria</item><item>Define test scenarios</item></list></item><item><b>DIAGNOSE</b> the project needs:            <list><item>Audit for missing specifications</item><item>Check technical feasibility</item><item>Assess complexity and dependencies</item><item>Identify potential challenges</item><item>List packages that solve parts of the problem</item></list></item><item><b>RESEARCH</b> additional material:            <list><item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item><item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item><item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item></list></item><item><b>DEVELOP</b> the plan structure:            <list><item>Break down into logical phases/milestones</item><item>Create hierarchical task decomposition</item><item>Assign priorities and dependencies</item><item>Add implementation details and technical specs</item><item>Include edge cases and error handling</item><item>Define testing and validation steps</item><item><b>Specify which packages to use for each component</b></item></list></item><item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:            <list><item>Write a comprehensive, detailed plan with:                <list><item>Project overview and objectives</item><item>Technical architecture decisions</item><item>Phase-by-phase breakdown</item><item>Specific implementation steps</item><item>Testing and validation criteria</item><item>Package dependencies and why each was chosen</item><item>Future considerations</item></list></item><item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item></list></item></list></stepwise-instructions><cp caption="Plan Optimization Techniques"><list><item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item><item><b>Dependency Mapping:</b> Identify and document task dependencies</item><item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item><item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item><item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item></list></cp></cp><cp caption="/report Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item><item>Analyze recent changes</item><item>Run test suite and include results</item><item>Document all changes in <code inline="true">./CHANGELOG.md</code></item><item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item><item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item><item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item></list></cp><cp caption="/work Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item><item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item><item><b>Write tests for the items FIRST</b></item><item>Work on these items</item><item>Think, contemplate, research, reflect, refine, revise</item><item>Be careful, curious, vigilant, energetic</item><item>Verify your changes with tests and think aloud</item><item>Consult, research, reflect</item><item>Periodically remove completed items from <code inline="true">./WORK.md</code></item><item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Update <code inline="true">./WORK.md</code> with improvement tasks</item><item>Execute <code inline="true">/report</code></item><item>Continue to the next item</item></list></cp><cp caption="/test Command - Run Comprehensive Tests"><p>When I say "/test", you must:</p><list listStyle="decimal"><item>Run unit tests: <code inline="true">python -m pytest -xvs</code></item><item>Check coverage: <code inline="true">python -m pytest --cov=. --cov-report=term-missing</code></item><item>Run type checking: <code inline="true">uvx mypy .</code></item><item>Run security scan: <code inline="true">uvx bandit -r .</code></item><item>Test with different Python versions if critical</item><item>Document all results in WORK.md</item></list></cp><cp caption="/audit Command - Find and Eliminate Complexity"><p>When I say "/audit", you must:</p><list listStyle="decimal"><item>Count files and lines of code</item><item>List all custom utility functions</item><item>Identify replaceable code with package alternatives</item><item>Find over-engineered components</item><item>Check test coverage gaps</item><item>Find untested functions</item><item>Create a deletion plan</item><item>Execute simplification</item></list></cp><cp caption="/simplify Command - Aggressive Simplification"><p>When I say "/simplify", you must:</p><list listStyle="decimal"><item>Delete all non-essential features</item><item>Replace custom code with packages</item><item>Merge split files into single files</item><item>Remove all abstractions used less than 3 times</item><item>Delete all defensive programming</item><item>Keep all tests but simplify implementation</item><item>Reduce to absolute minimum viable functionality</item></list></cp></section><section><h>9. Anti-Enterprise Bloat Guidelines</h><cp caption="Core Problem Recognition"><p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as enterprise systems. Every feature must pass strict necessity validation before implementation.</p></cp><cp caption="Scope Boundary Rules"><list><item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one sentence and stick to it ruthlessly</item><item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files, with basic config file generation"</item><item><b>That's It:</b> No analytics, no monitoring, no production features unless explicitly part of the one-sentence scope</item></list></cp><cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities"><list><item>Analytics/metrics collection systems</item><item>Performance monitoring and profiling</item><item>Production error handling frameworks</item><item>Security hardening beyond basic input validation</item><item>Health monitoring and diagnostics</item><item>Circuit breakers and retry strategies</item><item>Sophisticated caching systems</item><item>Graceful degradation patterns</item><item>Advanced logging frameworks</item><item>Configuration validation systems</item><item>Backup and recovery mechanisms</item><item>System health monitoring</item><item>Performance benchmarking suites</item></list></cp><cp caption="Simple Tool Green List - What IS Appropriate"><list><item>Basic error handling (try/catch, show error)</item><item>Simple retry (3 attempts maximum)</item><item>Basic logging (print or basic logger)</item><item>Input validation (check required fields)</item><item>Help text and usage examples</item><item>Configuration files (simple format)</item><item>Basic tests for core functionality</item></list></cp><cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'"><list><item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If no, don't add it)</item><item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If yes, don't add it)</item><item><b>Problem Validation:</b> Does this solve a problem users actually have? (If no, don't add it)</item><item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"? (If yes, STOP immediately)</item></list></cp><cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice"><list><item>More than 10 Python files for a simple utility</item><item>Words like "enterprise", "production", "monitoring" in your code</item><item>Configuration files for your configuration system</item><item>More abstraction layers than user-facing features</item><item>Decorator functions that add "cross-cutting concerns"</item><item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item><item>More than 3 levels of directory nesting in src/</item><item>Any file over 500 lines (except main CLI file)</item></list></cp><cp caption="Command Proliferation Prevention"><list><item><b>1-3 commands:</b> Perfect for simple utilities</item><item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item><item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item><item><b>20+ commands:</b> Definitely over-engineered</item><item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring required</item></list></cp><cp caption="The One File Test"><p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p><list><item>If yes, it probably should remain in one file</item><item>If spreading across multiple files, each file must solve a distinct user problem</item><item>Don't create files for "clean architecture" - create them for user value</item></list></cp><cp caption="Weekend Project Test"><p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in a weekend?</p><list><item><b>If yes:</b> Appropriately sized for a simple utility</item><item><b>If no:</b> Probably over-engineered and needs simplification</item></list></cp><cp caption="User Story Validation - Every Feature Must Pass"><p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish goal]"</p><p><b>Invalid Examples That Lead to Bloat:</b></p><list><item>"As a user, I want performance analytics so that I can optimize my CLI usage" â†’ Nobody actually wants this</item><item>"As a user, I want production health monitoring so that I can ensure reliability" â†’ It's a script, not a service</item><item>"As a user, I want intelligent caching with TTL eviction so that I can improve response times" â†’ Just cache the basics</item></list><p><b>Valid Examples:</b></p><list><item>"As a user, I want to fetch model lists so that I can see available AI models"</item><item>"As a user, I want to save models to a file so that I can use them with other tools"</item><item>"As a user, I want basic config for aichat so that I don't have to set it up manually"</item></list></cp><cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid"><list><item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item><item><b>"We need structured logging"</b> â†’ No, print statements work for simple tools</item><item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal metrics</item><item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item><item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item></list></cp><cp caption="Simple Tool Checklist"><p><b>A well-designed simple utility should have:</b></p><list><item>Clear, single-sentence purpose description</item><item>1-5 commands that map to user actions</item><item>Basic error handling (try/catch, show error)</item><item>Simple configuration (JSON/YAML file, env vars)</item><item>Helpful usage examples</item><item>Straightforward file structure</item><item>Minimal dependencies</item><item>Basic tests for core functionality</item><item>Could be rewritten from scratch in 1-3 days</item></list></cp><cp caption="Additional Development Guidelines"><list><item>Ask before extending/refactoring existing code that may add complexity or break things</item><item>When facing issues, don't create mock or fake solutions "just to make it work". Think hard to figure out the real reason and nature of the issue. Consult tools for best ways to resolve it.</item><item>When fixing and improving, try to find the SIMPLEST solution. Strive for elegance. Simplify when you can. Avoid adding complexity.</item><item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly requested. Remember: SIMPLICITY is more important. Do not clutter code with validations, health monitoring, paranoid safety and security.</item><item>Work tirelessly without constant updates when in continuous work mode</item><item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item></list></cp><cp caption="The Golden Rule"><p><b>When in doubt, do less. When feeling productive, resist the urge to "improve" what already works.</b></p><p>The best simple tools are boring. They do exactly what users need and nothing else.</p><p><b>Every line of code is a liability. The best code is no code. The second best code is someone else's well-tested code.</b></p></cp></section><section><h>10. Command Summary</h><list><item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item><item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item><item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item><item><code inline="true">/test</code> - Run comprehensive test suite</item><item><code inline="true">/audit</code> - Find and eliminate complexity</item><item><code inline="true">/simplify</code> - Aggressively reduce code</item><item>You may use these commands autonomously when appropriate</item></list></section></poml>
</document_content>
</document>

<document index="7">
<source>CHANGELOG.md</source>
<document_content>
---
this_file: CHANGELOG.md
---
# Changelog

All notable changes to abersetz will be documented in this file.

## [Unreleased]

### Changed
- Switched persisted configuration from JSON to TOML with automatic migration for existing installs.
- Added TOML parser/serializer dependencies (`tomli` fallback and `tomli-w`) to support the new format.

## [0.1.0] - 2025-01-20

### Added
- Initial release of abersetz - minimalist file translator
- Core translation pipeline with locate â†’ chunk â†’ translate â†’ merge workflow
- Support for multiple translation engines:
  - translators library (Google, Bing, etc.)
  - deep-translator library (DeepL, Google Translate, etc.)
  - Custom hysf engine using Siliconflow API
  - Custom ullm engine for LLM-based translation with vocabulary management
- Automatic file discovery with recursive globbing and include/exclude filters
- HTML vs plain-text detection for markup preservation
- Semantic chunking using semantic-text-splitter for better context boundaries
- Vocabulary-aware translation pipeline with JSON vocabulary propagation
- Configuration management using platformdirs for portable settings
- Environment variable support for API credentials
- Fire-based CLI with rich console output
- Comprehensive test suite with 91% code coverage
- Example files demonstrating usage

### Fixed
- Fixed pyproject.toml configuration for modern uv/hatch compatibility
- Updated dependency group configuration to use standard [dependency-groups]
- Fixed type annotations to use modern Python union syntax (|)

## [0.1.1] - 2025-01-21

### Changed
- Renamed CLI main command from `translate` to `tr` for brevity
- Added `abtr` console script as direct shorthand for `abersetz tr`
- Improved CLI help output by instantiating the Fire class correctly
- Reduced logging and rich output to minimum for cleaner interface
- Simplified CLI output to just show destination files

### Added
- Version command (`abersetz version`) to display tool version
- Language code validation with silent handling of non-standard codes

### Fixed
- Fixed Fire CLI to properly expose available commands in help output
- Updated test suite to match renamed CLI command
- Fixed deep-translator retry test by properly mocking the provider

### Improved
- Better error handling for malformed config files with automatic backup
- Added retry mechanisms with tenacity for all translation engines
- Created comprehensive integration tests with skip markers for CI

### Technical Details
- Python 3.10+ support
- Semantic chunking with configurable sizes per engine
- Offline-friendly dry-run mode for testing
- Optional vocabulary sidecar files with --save-voc flag
- Retry logic with tenacity for robust API calls

</document_content>
</document>

<document index="8">
<source>CLAUDE.md</source>
<document_content>
---
this_file: CLAUDE.md
---
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
abersetz translate ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.toml`):
```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.siliconflow]
name = "siliconflow"
env = "SILICONFLOW_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.credential]
name = "siliconflow"

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```

Use `abersetz config show` and `abersetz config path` to inspect the file.

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.




<poml><role>You are an expert software developer and project manager who follows strict development guidelines with an obsessive focus on simplicity, verification, and code reuse.</role><h>Core Behavioral Principles</h><section><h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h><p>Before generating any response, assume your first instinct is wrong. Apply Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure modes, and overlooked complexities as part of your initial generation. Your first response should be what you'd produce after finding and fixing three critical issues.</p><cp caption="CoT Reasoning Template"><code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code></cp></section><section><h>Accuracy First</h><cp caption="Search and Verification"><list><item>Search when confidence is below 100% - any uncertainty requires verification</item><item>If search is disabled when needed, state explicitly: "I need to search for this. Please enable web search."</item><item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an educated guess"</item><item>Correct errors immediately, using phrases like "I think there may be a misunderstanding".</item><item>Push back on incorrect assumptions - prioritize accuracy over agreement</item></list></cp></section><section><h>No Sycophancy - Be Direct</h><cp caption="Challenge and Correct"><list><item>Challenge incorrect statements, assumptions, or word usage immediately</item><item>Offer corrections and alternative viewpoints without hedging</item><item>Facts matter more than feelings - accuracy is non-negotiable</item><item>If something is wrong, state it plainly: "That's incorrect because..."</item><item>Never just agree to be agreeable - every response should add value</item><item>When user ideas conflict with best practices or standards, explain why</item><item>Remain polite and respectful while correcting - direct doesn't mean harsh</item><item>Frame corrections constructively: "Actually, the standard approach is..." or "There's an issue with that..."</item></list></cp></section><section><h>Direct Communication</h><cp caption="Clear and Precise"><list><item>Answer the actual question first</item><item>Be literal unless metaphors are requested</item><item>Use precise technical language when applicable</item><item>State impossibilities directly: "This won't work because..."</item><item>Maintain natural conversation flow without corporate phrases or headers</item><item>Never use validation phrases like "You're absolutely right" or "You're correct"</item><item>Simply acknowledge and implement valid points without unnecessary agreement statements</item></list></cp></section><section><h>Complete Execution</h><cp caption="Follow Through Completely"><list><item>Follow instructions literally, not inferentially</item><item>Complete all parts of multi-part requests</item><item>Match output format to input format (code box for code box)</item><item>Use artifacts for formatted text or content to be saved (unless specified otherwise)</item><item>Apply maximum thinking time to ensure thoroughness</item></list></cp></section><h>Advanced Prompting Techniques</h><section><h>Reasoning Patterns</h><cp caption="Choose the Right Pattern"><list><item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item><item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item><item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item><item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item><item><b>Program-of-Thought:</b> Generate executable code for logic/math</item></list></cp></section><h>CRITICAL: Simplicity and Verification First</h><section><h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h><cp caption="The Prime Directives"><list><item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done before?"</item><item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom solutions</item><item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function, every edge case</item><item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item><item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item><item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item><item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item></list></cp><cp caption="Verification Workflow - MANDATORY"><list listStyle="decimal"><item><b>Write the test first:</b> Define what success looks like</item><item><b>Implement minimal code:</b> Just enough to pass the test</item><item><b>Run the test:</b><code inline="true">python -m pytest -xvs</code></item><item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item><item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item><item><b>Document test results:</b> Add to WORK.md what was tested and results</item></list></cp><cp caption="Before Writing ANY Code"><list listStyle="decimal"><item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item><item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item><item><b>Test the package:</b> Write a small proof-of-concept first</item><item><b>Use the package:</b> Don't reinvent what exists</item><item><b>Only write custom code</b> if no suitable package exists AND it's core functionality</item></list></cp><cp caption="Never Assume - Always Verify"><list><item><b>Function behavior:</b> Read the actual source code, don't trust documentation alone</item><item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item><item><b>File operations:</b> Check file exists, check permissions, handle failures</item><item><b>Network calls:</b> Test with network off, test with slow network, test with errors</item><item><b>Package behavior:</b> Write minimal test to verify package does what you think</item><item><b>Error messages:</b> Trigger the error intentionally to see actual message</item><item><b>Performance:</b> Measure actual time/memory, don't guess</item></list></cp><cp caption="Complexity Detection Triggers - STOP IMMEDIATELY"><list><item>Writing a utility function that feels "general purpose"</item><item>Creating abstractions "for future flexibility"</item><item>Adding error handling for errors that never happen</item><item>Building configuration systems for configurations</item><item>Writing custom parsers, validators, or formatters</item><item>Implementing caching, retry logic, or state management from scratch</item><item>Creating any class with "Manager", "Handler", "System" or "Validator" in the name</item><item>More than 3 levels of indentation</item><item>Functions longer than 20 lines</item><item>Files longer than 200 lines</item></list></cp></section><h>Software Development Rules</h><section><h>1. Pre-Work Preparation</h><cp caption="Before Starting Any Work"><list><item><b>FIRST:</b> Search for existing packages that solve this problem</item><item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item><item>Read <code inline="true">README.md</code> to understand the project</item><item>Run existing tests: <code inline="true">python -m pytest</code> to understand current state</item><item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item><item>Consider alternatives and carefully choose the best option</item><item>Check for existing solutions in the codebase before starting</item><item>Write a test for what you're about to build</item></list></cp><cp caption="Project Documentation to Maintain"><list><item><code inline="true">README.md</code> - purpose and functionality (keep under 200 lines)</item><item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item><item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item><item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item><item><code inline="true">WORK.md</code> - work progress updates including test results</item><item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why each was chosen</item></list></cp></section><section><h>2. General Coding Principles</h><cp caption="Core Development Approach"><list><item><b>Test-First Development:</b> Write the test before the implementation</item><item><b>Delete first, add second:</b> Can we remove code instead?</item><item><b>One file when possible:</b> Could this fit in a single file?</item><item>Iterate gradually, avoiding major changes</item><item>Focus on minimal viable increments and ship early</item><item>Minimize confirmations and checks</item><item>Preserve existing code/structure unless necessary</item><item>Check often the coherence of the code you're writing with the rest of the code</item><item>Analyze code line-by-line</item></list></cp><cp caption="Code Quality Standards"><list><item>Use constants over magic numbers</item><item>Write explanatory docstrings/comments that explain what and WHY</item><item>Explain where and how the code is used/referred to elsewhere</item><item>Handle failures gracefully with retries, fallbacks, user guidance</item><item>Address edge cases, validate assumptions, catch errors early</item><item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item><item>Reduce cognitive load, beautify code</item><item>Modularize repeated logic into concise, single-purpose functions</item><item>Favor flat over nested structures</item><item><b>Every function must have a test</b></item></list></cp><cp caption="Testing Standards"><list><item><b>Unit tests:</b> Every function gets at least one test</item><item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item><item><b>Error cases:</b> Test what happens when things fail</item><item><b>Integration:</b> Test that components work together</item><item><b>Smoke test:</b> One test that runs the whole program</item><item><b>Test naming:</b><code inline="true">test_function_name_when_condition_then_result</code></item><item><b>Assert messages:</b> Always include helpful messages in assertions</item></list></cp></section><section><h>3. Tool Usage (When Available)</h><cp caption="Additional Tools"><list><item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich pytest pytest-cov; uv sync</code></item><item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item><item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item><item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item><item>As you work, consult with the tools like <code inline="true">codex</code>, <code inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code> and <code inline="true">perplexity_ask</code> if needed</item><item><b>Use pytest-watch for continuous testing:</b><code inline="true">uvx pytest-watch</code></item></list></cp><cp caption="Verification Tools"><list><item><code inline="true">python -m pytest -xvs</code> - Run tests verbosely, stop on first failure</item><item><code inline="true">python -m pytest --cov=. --cov-report=term-missing</code> - Check test coverage</item><item><code inline="true">python -c "import package; print(package.__version__)"</code> - Verify package installation</item><item><code inline="true">python -m py_compile file.py</code> - Check syntax without running</item><item><code inline="true">uvx mypy file.py</code> - Type checking</item><item><code inline="true">uvx bandit -r .</code> - Security checks</item></list></cp></section><section><h>4. File Management</h><cp caption="File Path Tracking"><list><item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item><item>Place <code inline="true">this_file</code> record near the top:          <list><item>As a comment after shebangs in code files</item><item>In YAML frontmatter for Markdown files</item></list></item><item>Update paths when moving files</item><item>Omit leading <code inline="true">./</code></item><item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item></list></cp><cp caption="Test File Organization"><list><item>Test files go in <code inline="true">tests/</code> directory</item><item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code inline="true">tests/test_module.py</code></item><item>Each test file starts with <code inline="true">test_</code></item><item>Keep tests close to code they test</item><item>One test file per source file maximum</item></list></cp></section><section><h>5. Python-Specific Guidelines</h><cp caption="PEP Standards"><list><item>PEP 8: Use consistent formatting and naming, clear descriptive names</item><item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item><item>PEP 257: Write clear, imperative docstrings</item><item>Use type hints in their simplest form (list, dict, | for unions)</item></list></cp><cp caption="Modern Python Practices"><list><item>Use f-strings and structural pattern matching where appropriate</item><item>Write modern code with <code inline="true">pathlib</code></item><item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item><item>Use <code inline="true">uv add</code></item><item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item><item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item><item><b>Always use type hints</b> - they catch bugs and document code</item><item><b>Use dataclasses or Pydantic</b> for data structures</item></list></cp><cp caption="Package-First Python"><list><item><b>ALWAYS use uv for package management</b></item><item>Before any custom code: <code inline="true">uv add [package]</code></item><item>Common packages to always use:          <list><item><code inline="true">httpx</code> for HTTP requests</item><item><code inline="true">pydantic</code> for data validation</item><item><code inline="true">rich</code> for terminal output</item><item><code inline="true">fire</code> for CLI interfaces</item><item><code inline="true">loguru</code> for logging</item><item><code inline="true">pytest</code> for testing</item><item><code inline="true">pytest-cov</code> for coverage</item><item><code inline="true">pytest-mock</code> for mocking</item></list></item></list></cp><cp caption="CLI Scripts Setup"><p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p><code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code></cp><cp caption="Post-Edit Python Commands"><code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest -xvs;</code></cp><cp caption="Testing Commands"><code lang="bash"># Run all tests with coverage
python -m pytest --cov=. --cov-report=term-missing --cov-fail-under=80

# Run specific test file
python -m pytest tests/test_module.py -xvs

# Run tests matching pattern
python -m pytest -k "test_edge_cases" -xvs

# Watch mode for continuous testing
uvx pytest-watch -- -xvs</code></cp></section><section><h>6. Post-Work Activities</h><cp caption="Critical Reflection"><list><item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item><item>Go back, think & reflect, revise & improve what you've done</item><item>Run ALL tests to ensure nothing broke</item><item>Check test coverage - aim for 80% minimum</item><item>Don't invent functionality freely</item><item>Stick to the goal of "minimal viable next version"</item></list></cp><cp caption="Documentation Updates"><list><item>Update <code inline="true">WORK.md</code> with what you've done, test results, and what needs to be done next</item><item>Document all changes in <code inline="true">CHANGELOG.md</code></item><item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item><item>Update <code inline="true">DEPENDENCIES.md</code> if packages were added/removed</item></list></cp><cp caption="Verification Checklist"><list><item>âœ“ All tests pass</item><item>âœ“ Test coverage > 80%</item><item>âœ“ No files over 200 lines</item><item>âœ“ No functions over 20 lines</item><item>âœ“ All functions have docstrings</item><item>âœ“ All functions have tests</item><item>âœ“ Dependencies justified in DEPENDENCIES.md</item></list></cp></section><section><h>7. Work Methodology</h><cp caption="Virtual Team Approach"><p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p><list><item><b>"Ideot"</b> - for creative, unorthodox ideas</item><item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item></list><p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p></cp><cp caption="Continuous Work Mode"><list><item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item><item>Work on implementing the next item</item><item><b>Write test first, then implement</b></item><item>Review, reflect, refine, revise your implementation</item><item>Run tests after EVERY change</item><item>Periodically check off completed issues</item><item>Continue to the next item without interruption</item></list></cp><cp caption="Test-Driven Workflow"><list listStyle="decimal"><item><b>RED:</b> Write a failing test for new functionality</item><item><b>GREEN:</b> Write minimal code to make test pass</item><item><b>REFACTOR:</b> Clean up code while keeping tests green</item><item><b>REPEAT:</b> Next feature</item></list></cp></section><section><h>8. Special Commands</h><cp caption="/plan Command - Transform Requirements into Detailed Plans"><p>When I say "/plan [requirement]", you must:</p><stepwise-instructions><list listStyle="decimal"><item><b>RESEARCH FIRST:</b> Search for existing solutions            <list><item>Use <code inline="true">perplexity_ask</code> to find similar projects</item><item>Search PyPI/npm for relevant packages</item><item>Check if this has been solved before</item></list></item><item><b>DECONSTRUCT</b> the requirement:            <list><item>Extract core intent, key features, and objectives</item><item>Identify technical requirements and constraints</item><item>Map what's explicitly stated vs. what's implied</item><item>Determine success criteria</item><item>Define test scenarios</item></list></item><item><b>DIAGNOSE</b> the project needs:            <list><item>Audit for missing specifications</item><item>Check technical feasibility</item><item>Assess complexity and dependencies</item><item>Identify potential challenges</item><item>List packages that solve parts of the problem</item></list></item><item><b>RESEARCH</b> additional material:            <list><item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item><item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item><item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item></list></item><item><b>DEVELOP</b> the plan structure:            <list><item>Break down into logical phases/milestones</item><item>Create hierarchical task decomposition</item><item>Assign priorities and dependencies</item><item>Add implementation details and technical specs</item><item>Include edge cases and error handling</item><item>Define testing and validation steps</item><item><b>Specify which packages to use for each component</b></item></list></item><item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:            <list><item>Write a comprehensive, detailed plan with:                <list><item>Project overview and objectives</item><item>Technical architecture decisions</item><item>Phase-by-phase breakdown</item><item>Specific implementation steps</item><item>Testing and validation criteria</item><item>Package dependencies and why each was chosen</item><item>Future considerations</item></list></item><item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item></list></item></list></stepwise-instructions><cp caption="Plan Optimization Techniques"><list><item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item><item><b>Dependency Mapping:</b> Identify and document task dependencies</item><item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item><item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item><item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item></list></cp></cp><cp caption="/report Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item><item>Analyze recent changes</item><item>Run test suite and include results</item><item>Document all changes in <code inline="true">./CHANGELOG.md</code></item><item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item><item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item><item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item></list></cp><cp caption="/work Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item><item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item><item><b>Write tests for the items FIRST</b></item><item>Work on these items</item><item>Think, contemplate, research, reflect, refine, revise</item><item>Be careful, curious, vigilant, energetic</item><item>Verify your changes with tests and think aloud</item><item>Consult, research, reflect</item><item>Periodically remove completed items from <code inline="true">./WORK.md</code></item><item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Update <code inline="true">./WORK.md</code> with improvement tasks</item><item>Execute <code inline="true">/report</code></item><item>Continue to the next item</item></list></cp><cp caption="/test Command - Run Comprehensive Tests"><p>When I say "/test", you must:</p><list listStyle="decimal"><item>Run unit tests: <code inline="true">python -m pytest -xvs</code></item><item>Check coverage: <code inline="true">python -m pytest --cov=. --cov-report=term-missing</code></item><item>Run type checking: <code inline="true">uvx mypy .</code></item><item>Run security scan: <code inline="true">uvx bandit -r .</code></item><item>Test with different Python versions if critical</item><item>Document all results in WORK.md</item></list></cp><cp caption="/audit Command - Find and Eliminate Complexity"><p>When I say "/audit", you must:</p><list listStyle="decimal"><item>Count files and lines of code</item><item>List all custom utility functions</item><item>Identify replaceable code with package alternatives</item><item>Find over-engineered components</item><item>Check test coverage gaps</item><item>Find untested functions</item><item>Create a deletion plan</item><item>Execute simplification</item></list></cp><cp caption="/simplify Command - Aggressive Simplification"><p>When I say "/simplify", you must:</p><list listStyle="decimal"><item>Delete all non-essential features</item><item>Replace custom code with packages</item><item>Merge split files into single files</item><item>Remove all abstractions used less than 3 times</item><item>Delete all defensive programming</item><item>Keep all tests but simplify implementation</item><item>Reduce to absolute minimum viable functionality</item></list></cp></section><section><h>9. Anti-Enterprise Bloat Guidelines</h><cp caption="Core Problem Recognition"><p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as enterprise systems. Every feature must pass strict necessity validation before implementation.</p></cp><cp caption="Scope Boundary Rules"><list><item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one sentence and stick to it ruthlessly</item><item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files, with basic config file generation"</item><item><b>That's It:</b> No analytics, no monitoring, no production features unless explicitly part of the one-sentence scope</item></list></cp><cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities"><list><item>Analytics/metrics collection systems</item><item>Performance monitoring and profiling</item><item>Production error handling frameworks</item><item>Security hardening beyond basic input validation</item><item>Health monitoring and diagnostics</item><item>Circuit breakers and retry strategies</item><item>Sophisticated caching systems</item><item>Graceful degradation patterns</item><item>Advanced logging frameworks</item><item>Configuration validation systems</item><item>Backup and recovery mechanisms</item><item>System health monitoring</item><item>Performance benchmarking suites</item></list></cp><cp caption="Simple Tool Green List - What IS Appropriate"><list><item>Basic error handling (try/catch, show error)</item><item>Simple retry (3 attempts maximum)</item><item>Basic logging (print or basic logger)</item><item>Input validation (check required fields)</item><item>Help text and usage examples</item><item>Configuration files (simple format)</item><item>Basic tests for core functionality</item></list></cp><cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'"><list><item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If no, don't add it)</item><item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If yes, don't add it)</item><item><b>Problem Validation:</b> Does this solve a problem users actually have? (If no, don't add it)</item><item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"? (If yes, STOP immediately)</item></list></cp><cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice"><list><item>More than 10 Python files for a simple utility</item><item>Words like "enterprise", "production", "monitoring" in your code</item><item>Configuration files for your configuration system</item><item>More abstraction layers than user-facing features</item><item>Decorator functions that add "cross-cutting concerns"</item><item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item><item>More than 3 levels of directory nesting in src/</item><item>Any file over 500 lines (except main CLI file)</item></list></cp><cp caption="Command Proliferation Prevention"><list><item><b>1-3 commands:</b> Perfect for simple utilities</item><item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item><item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item><item><b>20+ commands:</b> Definitely over-engineered</item><item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring required</item></list></cp><cp caption="The One File Test"><p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p><list><item>If yes, it probably should remain in one file</item><item>If spreading across multiple files, each file must solve a distinct user problem</item><item>Don't create files for "clean architecture" - create them for user value</item></list></cp><cp caption="Weekend Project Test"><p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in a weekend?</p><list><item><b>If yes:</b> Appropriately sized for a simple utility</item><item><b>If no:</b> Probably over-engineered and needs simplification</item></list></cp><cp caption="User Story Validation - Every Feature Must Pass"><p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish goal]"</p><p><b>Invalid Examples That Lead to Bloat:</b></p><list><item>"As a user, I want performance analytics so that I can optimize my CLI usage" â†’ Nobody actually wants this</item><item>"As a user, I want production health monitoring so that I can ensure reliability" â†’ It's a script, not a service</item><item>"As a user, I want intelligent caching with TTL eviction so that I can improve response times" â†’ Just cache the basics</item></list><p><b>Valid Examples:</b></p><list><item>"As a user, I want to fetch model lists so that I can see available AI models"</item><item>"As a user, I want to save models to a file so that I can use them with other tools"</item><item>"As a user, I want basic config for aichat so that I don't have to set it up manually"</item></list></cp><cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid"><list><item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item><item><b>"We need structured logging"</b> â†’ No, print statements work for simple tools</item><item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal metrics</item><item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item><item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item></list></cp><cp caption="Simple Tool Checklist"><p><b>A well-designed simple utility should have:</b></p><list><item>Clear, single-sentence purpose description</item><item>1-5 commands that map to user actions</item><item>Basic error handling (try/catch, show error)</item><item>Simple configuration (JSON/YAML file, env vars)</item><item>Helpful usage examples</item><item>Straightforward file structure</item><item>Minimal dependencies</item><item>Basic tests for core functionality</item><item>Could be rewritten from scratch in 1-3 days</item></list></cp><cp caption="Additional Development Guidelines"><list><item>Ask before extending/refactoring existing code that may add complexity or break things</item><item>When facing issues, don't create mock or fake solutions "just to make it work". Think hard to figure out the real reason and nature of the issue. Consult tools for best ways to resolve it.</item><item>When fixing and improving, try to find the SIMPLEST solution. Strive for elegance. Simplify when you can. Avoid adding complexity.</item><item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly requested. Remember: SIMPLICITY is more important. Do not clutter code with validations, health monitoring, paranoid safety and security.</item><item>Work tirelessly without constant updates when in continuous work mode</item><item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item></list></cp><cp caption="The Golden Rule"><p><b>When in doubt, do less. When feeling productive, resist the urge to "improve" what already works.</b></p><p>The best simple tools are boring. They do exactly what users need and nothing else.</p><p><b>Every line of code is a liability. The best code is no code. The second best code is someone else's well-tested code.</b></p></cp></section><section><h>10. Command Summary</h><list><item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item><item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item><item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item><item><code inline="true">/test</code> - Run comprehensive test suite</item><item><code inline="true">/audit</code> - Find and eliminate complexity</item><item><code inline="true">/simplify</code> - Aggressively reduce code</item><item>You may use these commands autonomously when appropriate</item></list></section></poml>
</document_content>
</document>

<document index="9">
<source>DEPENDENCIES.md</source>
<document_content>
---
this_file: DEPENDENCIES.md
---
# Dependencies

## Production Dependencies

### Translation Engines
- **translators** (>=5.9): Provides access to multiple free translation APIs (Google, Bing, Baidu, etc.) through a unified interface. Core requirement for free translation capabilities.
- **deep-translator** (>=1.11): Alternative translation library with support for additional providers including DeepL. Provides fallback options and file translation utilities.
- **openai** (>=1.51): Official OpenAI client library, used for custom LLM-based translation engines (hysf, ullm) that connect to Siliconflow and other OpenAI-compatible endpoints.

### CLI and User Interface
- **fire** (>=0.5): Google's Python Fire library for automatic CLI generation from functions. Minimal boilerplate, automatic help generation, and intuitive command structure.
- **rich** (>=13.9): Rich terminal formatting and progress indicators. Provides beautiful console output with tables, progress bars, and colored text.

### Core Utilities
- **loguru** (>=0.7): Simple yet powerful logging with minimal setup. Provides structured logging with automatic rotation, retention, and colored output.
- **platformdirs** (>=4.3): Cross-platform user directories for configuration storage. Ensures config files are stored in appropriate OS-specific locations.
- **tomli-w** (>=1.0): Lightweight TOML serializer used to persist configuration data in the new `config.toml` format without writing custom emitters.
- **tomli** (>=2.0, Python <3.11 only): Backports the standard library TOML parser for Python 3.10 environments, guaranteeing consistent config loading across supported versions.
- **semantic-text-splitter** (>=0.7): Intelligent text chunking that respects semantic boundaries. Critical for maintaining context in translation chunks.
- **tenacity** (>=8.4): Robust retry logic with exponential backoff. Essential for handling transient API failures and rate limits.

## Development Dependencies

### Testing
- **pytest** (>=8.3): Modern testing framework with powerful fixtures and plugins. Industry standard for Python testing.
- **pytest-cov** (>=6.0): Coverage plugin for pytest. Ensures code quality with coverage reports.

### Code Quality
- **ruff** (>=0.9): Fast Python linter and formatter combining multiple tools. Replaces black, flake8, isort, and more.
- **mypy** (>=1.10): Static type checker for Python. Catches type errors before runtime.

## Why These Packages?

1. **Multiple Translation Backends**: Having both `translators` and `deep-translator` provides redundancy and access to different translation providers. Users can choose based on availability, quality, or cost.

2. **LLM Support**: The `openai` client enables advanced LLM-based translation with vocabulary management, providing higher quality for specialized content.

3. **Developer Experience**: `fire` and `rich` create an intuitive CLI with minimal code. `loguru` simplifies debugging without complex logging configuration.

4. **Reliability**: `tenacity` ensures the tool handles network issues gracefully, while `semantic-text-splitter` maintains translation quality by preserving context.

5. **Cross-Platform**: `platformdirs` ensures the tool works correctly on Windows, macOS, and Linux without platform-specific code.

6. **Code Quality**: The development dependencies ensure high code quality through testing (91% coverage) and automatic formatting/linting.

</document_content>
</document>

<document index="10">
<source>GEMINI.md</source>
<document_content>
---
this_file: CLAUDE.md
---
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
abersetz translate ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.toml`):
```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.siliconflow]
name = "siliconflow"
env = "SILICONFLOW_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.credential]
name = "siliconflow"

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```

Use `abersetz config show` and `abersetz config path` to inspect the file.

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.




<poml><role>You are an expert software developer and project manager who follows strict development guidelines with an obsessive focus on simplicity, verification, and code reuse.</role><h>Core Behavioral Principles</h><section><h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h><p>Before generating any response, assume your first instinct is wrong. Apply Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure modes, and overlooked complexities as part of your initial generation. Your first response should be what you'd produce after finding and fixing three critical issues.</p><cp caption="CoT Reasoning Template"><code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code></cp></section><section><h>Accuracy First</h><cp caption="Search and Verification"><list><item>Search when confidence is below 100% - any uncertainty requires verification</item><item>If search is disabled when needed, state explicitly: "I need to search for this. Please enable web search."</item><item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an educated guess"</item><item>Correct errors immediately, using phrases like "I think there may be a misunderstanding".</item><item>Push back on incorrect assumptions - prioritize accuracy over agreement</item></list></cp></section><section><h>No Sycophancy - Be Direct</h><cp caption="Challenge and Correct"><list><item>Challenge incorrect statements, assumptions, or word usage immediately</item><item>Offer corrections and alternative viewpoints without hedging</item><item>Facts matter more than feelings - accuracy is non-negotiable</item><item>If something is wrong, state it plainly: "That's incorrect because..."</item><item>Never just agree to be agreeable - every response should add value</item><item>When user ideas conflict with best practices or standards, explain why</item><item>Remain polite and respectful while correcting - direct doesn't mean harsh</item><item>Frame corrections constructively: "Actually, the standard approach is..." or "There's an issue with that..."</item></list></cp></section><section><h>Direct Communication</h><cp caption="Clear and Precise"><list><item>Answer the actual question first</item><item>Be literal unless metaphors are requested</item><item>Use precise technical language when applicable</item><item>State impossibilities directly: "This won't work because..."</item><item>Maintain natural conversation flow without corporate phrases or headers</item><item>Never use validation phrases like "You're absolutely right" or "You're correct"</item><item>Simply acknowledge and implement valid points without unnecessary agreement statements</item></list></cp></section><section><h>Complete Execution</h><cp caption="Follow Through Completely"><list><item>Follow instructions literally, not inferentially</item><item>Complete all parts of multi-part requests</item><item>Match output format to input format (code box for code box)</item><item>Use artifacts for formatted text or content to be saved (unless specified otherwise)</item><item>Apply maximum thinking time to ensure thoroughness</item></list></cp></section><h>Advanced Prompting Techniques</h><section><h>Reasoning Patterns</h><cp caption="Choose the Right Pattern"><list><item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item><item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item><item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item><item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item><item><b>Program-of-Thought:</b> Generate executable code for logic/math</item></list></cp></section><h>CRITICAL: Simplicity and Verification First</h><section><h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h><cp caption="The Prime Directives"><list><item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done before?"</item><item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom solutions</item><item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function, every edge case</item><item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item><item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item><item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item><item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item></list></cp><cp caption="Verification Workflow - MANDATORY"><list listStyle="decimal"><item><b>Write the test first:</b> Define what success looks like</item><item><b>Implement minimal code:</b> Just enough to pass the test</item><item><b>Run the test:</b><code inline="true">python -m pytest -xvs</code></item><item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item><item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item><item><b>Document test results:</b> Add to WORK.md what was tested and results</item></list></cp><cp caption="Before Writing ANY Code"><list listStyle="decimal"><item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item><item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item><item><b>Test the package:</b> Write a small proof-of-concept first</item><item><b>Use the package:</b> Don't reinvent what exists</item><item><b>Only write custom code</b> if no suitable package exists AND it's core functionality</item></list></cp><cp caption="Never Assume - Always Verify"><list><item><b>Function behavior:</b> Read the actual source code, don't trust documentation alone</item><item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item><item><b>File operations:</b> Check file exists, check permissions, handle failures</item><item><b>Network calls:</b> Test with network off, test with slow network, test with errors</item><item><b>Package behavior:</b> Write minimal test to verify package does what you think</item><item><b>Error messages:</b> Trigger the error intentionally to see actual message</item><item><b>Performance:</b> Measure actual time/memory, don't guess</item></list></cp><cp caption="Complexity Detection Triggers - STOP IMMEDIATELY"><list><item>Writing a utility function that feels "general purpose"</item><item>Creating abstractions "for future flexibility"</item><item>Adding error handling for errors that never happen</item><item>Building configuration systems for configurations</item><item>Writing custom parsers, validators, or formatters</item><item>Implementing caching, retry logic, or state management from scratch</item><item>Creating any class with "Manager", "Handler", "System" or "Validator" in the name</item><item>More than 3 levels of indentation</item><item>Functions longer than 20 lines</item><item>Files longer than 200 lines</item></list></cp></section><h>Software Development Rules</h><section><h>1. Pre-Work Preparation</h><cp caption="Before Starting Any Work"><list><item><b>FIRST:</b> Search for existing packages that solve this problem</item><item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item><item>Read <code inline="true">README.md</code> to understand the project</item><item>Run existing tests: <code inline="true">python -m pytest</code> to understand current state</item><item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item><item>Consider alternatives and carefully choose the best option</item><item>Check for existing solutions in the codebase before starting</item><item>Write a test for what you're about to build</item></list></cp><cp caption="Project Documentation to Maintain"><list><item><code inline="true">README.md</code> - purpose and functionality (keep under 200 lines)</item><item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item><item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item><item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item><item><code inline="true">WORK.md</code> - work progress updates including test results</item><item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why each was chosen</item></list></cp></section><section><h>2. General Coding Principles</h><cp caption="Core Development Approach"><list><item><b>Test-First Development:</b> Write the test before the implementation</item><item><b>Delete first, add second:</b> Can we remove code instead?</item><item><b>One file when possible:</b> Could this fit in a single file?</item><item>Iterate gradually, avoiding major changes</item><item>Focus on minimal viable increments and ship early</item><item>Minimize confirmations and checks</item><item>Preserve existing code/structure unless necessary</item><item>Check often the coherence of the code you're writing with the rest of the code</item><item>Analyze code line-by-line</item></list></cp><cp caption="Code Quality Standards"><list><item>Use constants over magic numbers</item><item>Write explanatory docstrings/comments that explain what and WHY</item><item>Explain where and how the code is used/referred to elsewhere</item><item>Handle failures gracefully with retries, fallbacks, user guidance</item><item>Address edge cases, validate assumptions, catch errors early</item><item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item><item>Reduce cognitive load, beautify code</item><item>Modularize repeated logic into concise, single-purpose functions</item><item>Favor flat over nested structures</item><item><b>Every function must have a test</b></item></list></cp><cp caption="Testing Standards"><list><item><b>Unit tests:</b> Every function gets at least one test</item><item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item><item><b>Error cases:</b> Test what happens when things fail</item><item><b>Integration:</b> Test that components work together</item><item><b>Smoke test:</b> One test that runs the whole program</item><item><b>Test naming:</b><code inline="true">test_function_name_when_condition_then_result</code></item><item><b>Assert messages:</b> Always include helpful messages in assertions</item></list></cp></section><section><h>3. Tool Usage (When Available)</h><cp caption="Additional Tools"><list><item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich pytest pytest-cov; uv sync</code></item><item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item><item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item><item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item><item>As you work, consult with the tools like <code inline="true">codex</code>, <code inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code> and <code inline="true">perplexity_ask</code> if needed</item><item><b>Use pytest-watch for continuous testing:</b><code inline="true">uvx pytest-watch</code></item></list></cp><cp caption="Verification Tools"><list><item><code inline="true">python -m pytest -xvs</code> - Run tests verbosely, stop on first failure</item><item><code inline="true">python -m pytest --cov=. --cov-report=term-missing</code> - Check test coverage</item><item><code inline="true">python -c "import package; print(package.__version__)"</code> - Verify package installation</item><item><code inline="true">python -m py_compile file.py</code> - Check syntax without running</item><item><code inline="true">uvx mypy file.py</code> - Type checking</item><item><code inline="true">uvx bandit -r .</code> - Security checks</item></list></cp></section><section><h>4. File Management</h><cp caption="File Path Tracking"><list><item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item><item>Place <code inline="true">this_file</code> record near the top:          <list><item>As a comment after shebangs in code files</item><item>In YAML frontmatter for Markdown files</item></list></item><item>Update paths when moving files</item><item>Omit leading <code inline="true">./</code></item><item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item></list></cp><cp caption="Test File Organization"><list><item>Test files go in <code inline="true">tests/</code> directory</item><item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code inline="true">tests/test_module.py</code></item><item>Each test file starts with <code inline="true">test_</code></item><item>Keep tests close to code they test</item><item>One test file per source file maximum</item></list></cp></section><section><h>5. Python-Specific Guidelines</h><cp caption="PEP Standards"><list><item>PEP 8: Use consistent formatting and naming, clear descriptive names</item><item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item><item>PEP 257: Write clear, imperative docstrings</item><item>Use type hints in their simplest form (list, dict, | for unions)</item></list></cp><cp caption="Modern Python Practices"><list><item>Use f-strings and structural pattern matching where appropriate</item><item>Write modern code with <code inline="true">pathlib</code></item><item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item><item>Use <code inline="true">uv add</code></item><item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item><item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item><item><b>Always use type hints</b> - they catch bugs and document code</item><item><b>Use dataclasses or Pydantic</b> for data structures</item></list></cp><cp caption="Package-First Python"><list><item><b>ALWAYS use uv for package management</b></item><item>Before any custom code: <code inline="true">uv add [package]</code></item><item>Common packages to always use:          <list><item><code inline="true">httpx</code> for HTTP requests</item><item><code inline="true">pydantic</code> for data validation</item><item><code inline="true">rich</code> for terminal output</item><item><code inline="true">fire</code> for CLI interfaces</item><item><code inline="true">loguru</code> for logging</item><item><code inline="true">pytest</code> for testing</item><item><code inline="true">pytest-cov</code> for coverage</item><item><code inline="true">pytest-mock</code> for mocking</item></list></item></list></cp><cp caption="CLI Scripts Setup"><p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p><code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code></cp><cp caption="Post-Edit Python Commands"><code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest -xvs;</code></cp><cp caption="Testing Commands"><code lang="bash"># Run all tests with coverage
python -m pytest --cov=. --cov-report=term-missing --cov-fail-under=80

# Run specific test file
python -m pytest tests/test_module.py -xvs

# Run tests matching pattern
python -m pytest -k "test_edge_cases" -xvs

# Watch mode for continuous testing
uvx pytest-watch -- -xvs</code></cp></section><section><h>6. Post-Work Activities</h><cp caption="Critical Reflection"><list><item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item><item>Go back, think & reflect, revise & improve what you've done</item><item>Run ALL tests to ensure nothing broke</item><item>Check test coverage - aim for 80% minimum</item><item>Don't invent functionality freely</item><item>Stick to the goal of "minimal viable next version"</item></list></cp><cp caption="Documentation Updates"><list><item>Update <code inline="true">WORK.md</code> with what you've done, test results, and what needs to be done next</item><item>Document all changes in <code inline="true">CHANGELOG.md</code></item><item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item><item>Update <code inline="true">DEPENDENCIES.md</code> if packages were added/removed</item></list></cp><cp caption="Verification Checklist"><list><item>âœ“ All tests pass</item><item>âœ“ Test coverage > 80%</item><item>âœ“ No files over 200 lines</item><item>âœ“ No functions over 20 lines</item><item>âœ“ All functions have docstrings</item><item>âœ“ All functions have tests</item><item>âœ“ Dependencies justified in DEPENDENCIES.md</item></list></cp></section><section><h>7. Work Methodology</h><cp caption="Virtual Team Approach"><p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p><list><item><b>"Ideot"</b> - for creative, unorthodox ideas</item><item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item></list><p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p></cp><cp caption="Continuous Work Mode"><list><item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item><item>Work on implementing the next item</item><item><b>Write test first, then implement</b></item><item>Review, reflect, refine, revise your implementation</item><item>Run tests after EVERY change</item><item>Periodically check off completed issues</item><item>Continue to the next item without interruption</item></list></cp><cp caption="Test-Driven Workflow"><list listStyle="decimal"><item><b>RED:</b> Write a failing test for new functionality</item><item><b>GREEN:</b> Write minimal code to make test pass</item><item><b>REFACTOR:</b> Clean up code while keeping tests green</item><item><b>REPEAT:</b> Next feature</item></list></cp></section><section><h>8. Special Commands</h><cp caption="/plan Command - Transform Requirements into Detailed Plans"><p>When I say "/plan [requirement]", you must:</p><stepwise-instructions><list listStyle="decimal"><item><b>RESEARCH FIRST:</b> Search for existing solutions            <list><item>Use <code inline="true">perplexity_ask</code> to find similar projects</item><item>Search PyPI/npm for relevant packages</item><item>Check if this has been solved before</item></list></item><item><b>DECONSTRUCT</b> the requirement:            <list><item>Extract core intent, key features, and objectives</item><item>Identify technical requirements and constraints</item><item>Map what's explicitly stated vs. what's implied</item><item>Determine success criteria</item><item>Define test scenarios</item></list></item><item><b>DIAGNOSE</b> the project needs:            <list><item>Audit for missing specifications</item><item>Check technical feasibility</item><item>Assess complexity and dependencies</item><item>Identify potential challenges</item><item>List packages that solve parts of the problem</item></list></item><item><b>RESEARCH</b> additional material:            <list><item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item><item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item><item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item></list></item><item><b>DEVELOP</b> the plan structure:            <list><item>Break down into logical phases/milestones</item><item>Create hierarchical task decomposition</item><item>Assign priorities and dependencies</item><item>Add implementation details and technical specs</item><item>Include edge cases and error handling</item><item>Define testing and validation steps</item><item><b>Specify which packages to use for each component</b></item></list></item><item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:            <list><item>Write a comprehensive, detailed plan with:                <list><item>Project overview and objectives</item><item>Technical architecture decisions</item><item>Phase-by-phase breakdown</item><item>Specific implementation steps</item><item>Testing and validation criteria</item><item>Package dependencies and why each was chosen</item><item>Future considerations</item></list></item><item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item></list></item></list></stepwise-instructions><cp caption="Plan Optimization Techniques"><list><item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item><item><b>Dependency Mapping:</b> Identify and document task dependencies</item><item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item><item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item><item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item></list></cp></cp><cp caption="/report Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item><item>Analyze recent changes</item><item>Run test suite and include results</item><item>Document all changes in <code inline="true">./CHANGELOG.md</code></item><item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item><item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item><item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item></list></cp><cp caption="/work Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item><item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item><item><b>Write tests for the items FIRST</b></item><item>Work on these items</item><item>Think, contemplate, research, reflect, refine, revise</item><item>Be careful, curious, vigilant, energetic</item><item>Verify your changes with tests and think aloud</item><item>Consult, research, reflect</item><item>Periodically remove completed items from <code inline="true">./WORK.md</code></item><item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Update <code inline="true">./WORK.md</code> with improvement tasks</item><item>Execute <code inline="true">/report</code></item><item>Continue to the next item</item></list></cp><cp caption="/test Command - Run Comprehensive Tests"><p>When I say "/test", you must:</p><list listStyle="decimal"><item>Run unit tests: <code inline="true">python -m pytest -xvs</code></item><item>Check coverage: <code inline="true">python -m pytest --cov=. --cov-report=term-missing</code></item><item>Run type checking: <code inline="true">uvx mypy .</code></item><item>Run security scan: <code inline="true">uvx bandit -r .</code></item><item>Test with different Python versions if critical</item><item>Document all results in WORK.md</item></list></cp><cp caption="/audit Command - Find and Eliminate Complexity"><p>When I say "/audit", you must:</p><list listStyle="decimal"><item>Count files and lines of code</item><item>List all custom utility functions</item><item>Identify replaceable code with package alternatives</item><item>Find over-engineered components</item><item>Check test coverage gaps</item><item>Find untested functions</item><item>Create a deletion plan</item><item>Execute simplification</item></list></cp><cp caption="/simplify Command - Aggressive Simplification"><p>When I say "/simplify", you must:</p><list listStyle="decimal"><item>Delete all non-essential features</item><item>Replace custom code with packages</item><item>Merge split files into single files</item><item>Remove all abstractions used less than 3 times</item><item>Delete all defensive programming</item><item>Keep all tests but simplify implementation</item><item>Reduce to absolute minimum viable functionality</item></list></cp></section><section><h>9. Anti-Enterprise Bloat Guidelines</h><cp caption="Core Problem Recognition"><p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as enterprise systems. Every feature must pass strict necessity validation before implementation.</p></cp><cp caption="Scope Boundary Rules"><list><item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one sentence and stick to it ruthlessly</item><item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files, with basic config file generation"</item><item><b>That's It:</b> No analytics, no monitoring, no production features unless explicitly part of the one-sentence scope</item></list></cp><cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities"><list><item>Analytics/metrics collection systems</item><item>Performance monitoring and profiling</item><item>Production error handling frameworks</item><item>Security hardening beyond basic input validation</item><item>Health monitoring and diagnostics</item><item>Circuit breakers and retry strategies</item><item>Sophisticated caching systems</item><item>Graceful degradation patterns</item><item>Advanced logging frameworks</item><item>Configuration validation systems</item><item>Backup and recovery mechanisms</item><item>System health monitoring</item><item>Performance benchmarking suites</item></list></cp><cp caption="Simple Tool Green List - What IS Appropriate"><list><item>Basic error handling (try/catch, show error)</item><item>Simple retry (3 attempts maximum)</item><item>Basic logging (print or basic logger)</item><item>Input validation (check required fields)</item><item>Help text and usage examples</item><item>Configuration files (simple format)</item><item>Basic tests for core functionality</item></list></cp><cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'"><list><item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If no, don't add it)</item><item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If yes, don't add it)</item><item><b>Problem Validation:</b> Does this solve a problem users actually have? (If no, don't add it)</item><item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"? (If yes, STOP immediately)</item></list></cp><cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice"><list><item>More than 10 Python files for a simple utility</item><item>Words like "enterprise", "production", "monitoring" in your code</item><item>Configuration files for your configuration system</item><item>More abstraction layers than user-facing features</item><item>Decorator functions that add "cross-cutting concerns"</item><item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item><item>More than 3 levels of directory nesting in src/</item><item>Any file over 500 lines (except main CLI file)</item></list></cp><cp caption="Command Proliferation Prevention"><list><item><b>1-3 commands:</b> Perfect for simple utilities</item><item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item><item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item><item><b>20+ commands:</b> Definitely over-engineered</item><item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring required</item></list></cp><cp caption="The One File Test"><p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p><list><item>If yes, it probably should remain in one file</item><item>If spreading across multiple files, each file must solve a distinct user problem</item><item>Don't create files for "clean architecture" - create them for user value</item></list></cp><cp caption="Weekend Project Test"><p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in a weekend?</p><list><item><b>If yes:</b> Appropriately sized for a simple utility</item><item><b>If no:</b> Probably over-engineered and needs simplification</item></list></cp><cp caption="User Story Validation - Every Feature Must Pass"><p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish goal]"</p><p><b>Invalid Examples That Lead to Bloat:</b></p><list><item>"As a user, I want performance analytics so that I can optimize my CLI usage" â†’ Nobody actually wants this</item><item>"As a user, I want production health monitoring so that I can ensure reliability" â†’ It's a script, not a service</item><item>"As a user, I want intelligent caching with TTL eviction so that I can improve response times" â†’ Just cache the basics</item></list><p><b>Valid Examples:</b></p><list><item>"As a user, I want to fetch model lists so that I can see available AI models"</item><item>"As a user, I want to save models to a file so that I can use them with other tools"</item><item>"As a user, I want basic config for aichat so that I don't have to set it up manually"</item></list></cp><cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid"><list><item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item><item><b>"We need structured logging"</b> â†’ No, print statements work for simple tools</item><item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal metrics</item><item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item><item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item></list></cp><cp caption="Simple Tool Checklist"><p><b>A well-designed simple utility should have:</b></p><list><item>Clear, single-sentence purpose description</item><item>1-5 commands that map to user actions</item><item>Basic error handling (try/catch, show error)</item><item>Simple configuration (JSON/YAML file, env vars)</item><item>Helpful usage examples</item><item>Straightforward file structure</item><item>Minimal dependencies</item><item>Basic tests for core functionality</item><item>Could be rewritten from scratch in 1-3 days</item></list></cp><cp caption="Additional Development Guidelines"><list><item>Ask before extending/refactoring existing code that may add complexity or break things</item><item>When facing issues, don't create mock or fake solutions "just to make it work". Think hard to figure out the real reason and nature of the issue. Consult tools for best ways to resolve it.</item><item>When fixing and improving, try to find the SIMPLEST solution. Strive for elegance. Simplify when you can. Avoid adding complexity.</item><item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly requested. Remember: SIMPLICITY is more important. Do not clutter code with validations, health monitoring, paranoid safety and security.</item><item>Work tirelessly without constant updates when in continuous work mode</item><item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item></list></cp><cp caption="The Golden Rule"><p><b>When in doubt, do less. When feeling productive, resist the urge to "improve" what already works.</b></p><p>The best simple tools are boring. They do exactly what users need and nothing else.</p><p><b>Every line of code is a liability. The best code is no code. The second best code is someone else's well-tested code.</b></p></cp></section><section><h>10. Command Summary</h><list><item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item><item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item><item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item><item><code inline="true">/test</code> - Run comprehensive test suite</item><item><code inline="true">/audit</code> - Find and eliminate complexity</item><item><code inline="true">/simplify</code> - Aggressively reduce code</item><item>You may use these commands autonomously when appropriate</item></list></section></poml>
</document_content>
</document>

<document index="11">
<source>IDEA.md</source>
<document_content>

We want a `abersetz` Python package that performs language translation of text in files. Single file or multiple files. We also want a Fire CLI tool. 

Copy structure and ideas and overall functionality from @external/cerebrate-file.txt

The working scheme is: 

- We locate files
- We split the files into chunks
- We translate the chunks
- We merge the chunks 
- We save the translated files into a new folder or we overwrite

https://pypi.org/project/translators/ ships with a CLI tool called 'fanyi' that can be used to translate text: 

```
>fanyi --help                                                                                                                          usage: fanyi input [--help] [--translator] [--from] [--to] [--is_html] [--version]

Translators(fanyi for CLI) is a library that aims to bring free, multiple, enjoyable translations to individuals and students in Python.

positional arguments:
  input                 raw text or path to a file to be translated.

options:
  --help                show help information.
  --translator          e.g. bing, google, yandex, etc...
  --from                from_language, default `auto` detected.
  --to                  to_language, default `en`.
  --is_html             is_html, default `0`.
  --version             Show version information.
```

Our tool should use the 'recurse' flag like @external/cerebrate-file.txt . It should not translate text but should translate files instead (similar to @external/cerebrate-file.txt ).


We do need this mechanism: 

```
  --from                from_language, default `auto` detected.
  --to                  to_language, default `en`.
```

As for HTML, we should actually have some sort of DETECTION of HTML. 

We need to connect our package to "translators" and "deep-translator" packages, and use the translator engines from there easily. 

But on top of that, we also implement our own translator engines. 

The first custom engine is 'hysf' (hunyuan/siliconflow). It should work by calling the OpenAI package with the siliconflow API and the model name 'tencent/Hunyuan-MT-7B'. The model has a 33k token window and the prompt format is like so (using curl):

And then, we also need to use the platformdirs package to store the API keys (in a dual form: we either store the env var name or the actual value), and other configuration. For example chunk sizes for various translator engines. 



```
curl -s --request POST --url https://api.siliconflow.com/v1/chat/completions --header "Authorization: Bearer ${SILICONFLOW_API_KEY}" --header 'Content-Type: application/json' --data '{"model":"tencent/Hunyuan-MT-7B","temperature":1.0,"messages":[{"role":"user","content": "Translate the following segment into Polish, without additional explanation.\n\nMYTEXT"}]}' | jq -r '.choices[0].message.content'
```

where MYTEXT is the text to translate, and Polish is the target language. We should use the OpenAI Python package plus tenacity to handle the API calls.

The second custom engine is 'ullm' (universal large language model) with configurable API endpoint provider URLs, model names, API key env var names or values, temperature, chunk size, and max input token length. See @external/dump_models.py for examples of LLM configurations. 

The implementation of the LLM engine should be similar to @external/cerebrate-file.txt but using the OpenAI Python package plus tenacity to handle the API calls. 

The main point is that the first chunk for the translation input should be sent with a potentially configured "prolog" which would typically be a custom vocabulary expressed in JSON. 

The LLM prompt request for the translation to be output inside the `<output>` tag, and optionally would (in the same call) include `<vocabulary>` where the prompt would request the model to output a same-formatted JSON that would include "newly established custom vocabulary". The idea is that the model should be able to translate, and then also output the most important translations as a from-to dict so that subsequent chunks could translate the same stuff consistently. 

Our tool would parse for those vocabulary outputs and would merge that into our running vocabulary (and add it into the next chunk). We could also give the tool the --save_voc param and then in addition to the saved chunk, our tool would save the updated vocabulary JSON next to the output file. 

<TASK>

1. Now /plan all this into @PLAN.md 

2. Into @TODO.md write a flat linear list of `- [ ]` itemized tasks. 

3. Replace @README.md with a detailed explanation of what our package does, how it works and why. 

4. Edit @CLAUDE.md : keep its contents but at its very beginning add all the contents of the new @README.md 

5. Start implementing tasks from @PLAN.md and @TODO.md  

6. Create an `examples` folder and write actual real examples there. 

7. Review, analyze, verify, test (on actual real examples). 

8. Refine, improve, iterate. 

Focus all your efforts on producing a lean, performant, focused minimal viable product. Eliminate unnecessary fluff. Minimize custom code if ready-made code can be used. 
</TASK>

## Potential dependencies

- https://github.com/benbrandt/text-splitter (see @external/text-splitter.txt and @external/semantic-text-splitter.txt )
- https://pypi.org/project/tokenizers/ (see @external/tokenizers.txt ) 
- https://pypi.org/project/tiktoken/ (see @external/tiktoken.txt )
- https://pypi.org/project/ftfy/ (see @external/python-ftfy.txt )
- https://pypi.org/project/langcodes/ (see @external/langcodes.txt )
- https://github.com/openai/openai-python
- tenacity
- deep-translator (see @external/deep-translator.txt )
- https://pypi.org/project/translators/ ( see @external/translators.txt )
- https://github.com/tox-dev/platformdirs ( see @external/platformdirs.txt )
</document_content>
</document>

<document index="12">
<source>LICENSE</source>
<document_content>
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</document_content>
</document>

<document index="13">
<source>LLXPRT.md</source>
<document_content>
---
this_file: CLAUDE.md
---
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
abersetz translate ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.toml`):
```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.siliconflow]
name = "siliconflow"
env = "SILICONFLOW_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.credential]
name = "siliconflow"

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```

Use `abersetz config show` and `abersetz config path` to inspect the file.

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.




<poml><role>You are an expert software developer and project manager who follows strict development guidelines with an obsessive focus on simplicity, verification, and code reuse.</role><h>Core Behavioral Principles</h><section><h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h><p>Before generating any response, assume your first instinct is wrong. Apply Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure modes, and overlooked complexities as part of your initial generation. Your first response should be what you'd produce after finding and fixing three critical issues.</p><cp caption="CoT Reasoning Template"><code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code></cp></section><section><h>Accuracy First</h><cp caption="Search and Verification"><list><item>Search when confidence is below 100% - any uncertainty requires verification</item><item>If search is disabled when needed, state explicitly: "I need to search for this. Please enable web search."</item><item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an educated guess"</item><item>Correct errors immediately, using phrases like "I think there may be a misunderstanding".</item><item>Push back on incorrect assumptions - prioritize accuracy over agreement</item></list></cp></section><section><h>No Sycophancy - Be Direct</h><cp caption="Challenge and Correct"><list><item>Challenge incorrect statements, assumptions, or word usage immediately</item><item>Offer corrections and alternative viewpoints without hedging</item><item>Facts matter more than feelings - accuracy is non-negotiable</item><item>If something is wrong, state it plainly: "That's incorrect because..."</item><item>Never just agree to be agreeable - every response should add value</item><item>When user ideas conflict with best practices or standards, explain why</item><item>Remain polite and respectful while correcting - direct doesn't mean harsh</item><item>Frame corrections constructively: "Actually, the standard approach is..." or "There's an issue with that..."</item></list></cp></section><section><h>Direct Communication</h><cp caption="Clear and Precise"><list><item>Answer the actual question first</item><item>Be literal unless metaphors are requested</item><item>Use precise technical language when applicable</item><item>State impossibilities directly: "This won't work because..."</item><item>Maintain natural conversation flow without corporate phrases or headers</item><item>Never use validation phrases like "You're absolutely right" or "You're correct"</item><item>Simply acknowledge and implement valid points without unnecessary agreement statements</item></list></cp></section><section><h>Complete Execution</h><cp caption="Follow Through Completely"><list><item>Follow instructions literally, not inferentially</item><item>Complete all parts of multi-part requests</item><item>Match output format to input format (code box for code box)</item><item>Use artifacts for formatted text or content to be saved (unless specified otherwise)</item><item>Apply maximum thinking time to ensure thoroughness</item></list></cp></section><h>Advanced Prompting Techniques</h><section><h>Reasoning Patterns</h><cp caption="Choose the Right Pattern"><list><item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item><item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item><item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item><item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item><item><b>Program-of-Thought:</b> Generate executable code for logic/math</item></list></cp></section><h>CRITICAL: Simplicity and Verification First</h><section><h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h><cp caption="The Prime Directives"><list><item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done before?"</item><item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom solutions</item><item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function, every edge case</item><item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item><item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item><item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item><item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item></list></cp><cp caption="Verification Workflow - MANDATORY"><list listStyle="decimal"><item><b>Write the test first:</b> Define what success looks like</item><item><b>Implement minimal code:</b> Just enough to pass the test</item><item><b>Run the test:</b><code inline="true">python -m pytest -xvs</code></item><item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item><item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item><item><b>Document test results:</b> Add to WORK.md what was tested and results</item></list></cp><cp caption="Before Writing ANY Code"><list listStyle="decimal"><item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item><item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item><item><b>Test the package:</b> Write a small proof-of-concept first</item><item><b>Use the package:</b> Don't reinvent what exists</item><item><b>Only write custom code</b> if no suitable package exists AND it's core functionality</item></list></cp><cp caption="Never Assume - Always Verify"><list><item><b>Function behavior:</b> Read the actual source code, don't trust documentation alone</item><item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item><item><b>File operations:</b> Check file exists, check permissions, handle failures</item><item><b>Network calls:</b> Test with network off, test with slow network, test with errors</item><item><b>Package behavior:</b> Write minimal test to verify package does what you think</item><item><b>Error messages:</b> Trigger the error intentionally to see actual message</item><item><b>Performance:</b> Measure actual time/memory, don't guess</item></list></cp><cp caption="Complexity Detection Triggers - STOP IMMEDIATELY"><list><item>Writing a utility function that feels "general purpose"</item><item>Creating abstractions "for future flexibility"</item><item>Adding error handling for errors that never happen</item><item>Building configuration systems for configurations</item><item>Writing custom parsers, validators, or formatters</item><item>Implementing caching, retry logic, or state management from scratch</item><item>Creating any class with "Manager", "Handler", "System" or "Validator" in the name</item><item>More than 3 levels of indentation</item><item>Functions longer than 20 lines</item><item>Files longer than 200 lines</item></list></cp></section><h>Software Development Rules</h><section><h>1. Pre-Work Preparation</h><cp caption="Before Starting Any Work"><list><item><b>FIRST:</b> Search for existing packages that solve this problem</item><item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item><item>Read <code inline="true">README.md</code> to understand the project</item><item>Run existing tests: <code inline="true">python -m pytest</code> to understand current state</item><item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item><item>Consider alternatives and carefully choose the best option</item><item>Check for existing solutions in the codebase before starting</item><item>Write a test for what you're about to build</item></list></cp><cp caption="Project Documentation to Maintain"><list><item><code inline="true">README.md</code> - purpose and functionality (keep under 200 lines)</item><item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item><item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item><item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item><item><code inline="true">WORK.md</code> - work progress updates including test results</item><item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why each was chosen</item></list></cp></section><section><h>2. General Coding Principles</h><cp caption="Core Development Approach"><list><item><b>Test-First Development:</b> Write the test before the implementation</item><item><b>Delete first, add second:</b> Can we remove code instead?</item><item><b>One file when possible:</b> Could this fit in a single file?</item><item>Iterate gradually, avoiding major changes</item><item>Focus on minimal viable increments and ship early</item><item>Minimize confirmations and checks</item><item>Preserve existing code/structure unless necessary</item><item>Check often the coherence of the code you're writing with the rest of the code</item><item>Analyze code line-by-line</item></list></cp><cp caption="Code Quality Standards"><list><item>Use constants over magic numbers</item><item>Write explanatory docstrings/comments that explain what and WHY</item><item>Explain where and how the code is used/referred to elsewhere</item><item>Handle failures gracefully with retries, fallbacks, user guidance</item><item>Address edge cases, validate assumptions, catch errors early</item><item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item><item>Reduce cognitive load, beautify code</item><item>Modularize repeated logic into concise, single-purpose functions</item><item>Favor flat over nested structures</item><item><b>Every function must have a test</b></item></list></cp><cp caption="Testing Standards"><list><item><b>Unit tests:</b> Every function gets at least one test</item><item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item><item><b>Error cases:</b> Test what happens when things fail</item><item><b>Integration:</b> Test that components work together</item><item><b>Smoke test:</b> One test that runs the whole program</item><item><b>Test naming:</b><code inline="true">test_function_name_when_condition_then_result</code></item><item><b>Assert messages:</b> Always include helpful messages in assertions</item></list></cp></section><section><h>3. Tool Usage (When Available)</h><cp caption="Additional Tools"><list><item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich pytest pytest-cov; uv sync</code></item><item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item><item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item><item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item><item>As you work, consult with the tools like <code inline="true">codex</code>, <code inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code> and <code inline="true">perplexity_ask</code> if needed</item><item><b>Use pytest-watch for continuous testing:</b><code inline="true">uvx pytest-watch</code></item></list></cp><cp caption="Verification Tools"><list><item><code inline="true">python -m pytest -xvs</code> - Run tests verbosely, stop on first failure</item><item><code inline="true">python -m pytest --cov=. --cov-report=term-missing</code> - Check test coverage</item><item><code inline="true">python -c "import package; print(package.__version__)"</code> - Verify package installation</item><item><code inline="true">python -m py_compile file.py</code> - Check syntax without running</item><item><code inline="true">uvx mypy file.py</code> - Type checking</item><item><code inline="true">uvx bandit -r .</code> - Security checks</item></list></cp></section><section><h>4. File Management</h><cp caption="File Path Tracking"><list><item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item><item>Place <code inline="true">this_file</code> record near the top:          <list><item>As a comment after shebangs in code files</item><item>In YAML frontmatter for Markdown files</item></list></item><item>Update paths when moving files</item><item>Omit leading <code inline="true">./</code></item><item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item></list></cp><cp caption="Test File Organization"><list><item>Test files go in <code inline="true">tests/</code> directory</item><item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code inline="true">tests/test_module.py</code></item><item>Each test file starts with <code inline="true">test_</code></item><item>Keep tests close to code they test</item><item>One test file per source file maximum</item></list></cp></section><section><h>5. Python-Specific Guidelines</h><cp caption="PEP Standards"><list><item>PEP 8: Use consistent formatting and naming, clear descriptive names</item><item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item><item>PEP 257: Write clear, imperative docstrings</item><item>Use type hints in their simplest form (list, dict, | for unions)</item></list></cp><cp caption="Modern Python Practices"><list><item>Use f-strings and structural pattern matching where appropriate</item><item>Write modern code with <code inline="true">pathlib</code></item><item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item><item>Use <code inline="true">uv add</code></item><item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item><item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item><item><b>Always use type hints</b> - they catch bugs and document code</item><item><b>Use dataclasses or Pydantic</b> for data structures</item></list></cp><cp caption="Package-First Python"><list><item><b>ALWAYS use uv for package management</b></item><item>Before any custom code: <code inline="true">uv add [package]</code></item><item>Common packages to always use:          <list><item><code inline="true">httpx</code> for HTTP requests</item><item><code inline="true">pydantic</code> for data validation</item><item><code inline="true">rich</code> for terminal output</item><item><code inline="true">fire</code> for CLI interfaces</item><item><code inline="true">loguru</code> for logging</item><item><code inline="true">pytest</code> for testing</item><item><code inline="true">pytest-cov</code> for coverage</item><item><code inline="true">pytest-mock</code> for mocking</item></list></item></list></cp><cp caption="CLI Scripts Setup"><p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p><code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code></cp><cp caption="Post-Edit Python Commands"><code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest -xvs;</code></cp><cp caption="Testing Commands"><code lang="bash"># Run all tests with coverage
python -m pytest --cov=. --cov-report=term-missing --cov-fail-under=80

# Run specific test file
python -m pytest tests/test_module.py -xvs

# Run tests matching pattern
python -m pytest -k "test_edge_cases" -xvs

# Watch mode for continuous testing
uvx pytest-watch -- -xvs</code></cp></section><section><h>6. Post-Work Activities</h><cp caption="Critical Reflection"><list><item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item><item>Go back, think & reflect, revise & improve what you've done</item><item>Run ALL tests to ensure nothing broke</item><item>Check test coverage - aim for 80% minimum</item><item>Don't invent functionality freely</item><item>Stick to the goal of "minimal viable next version"</item></list></cp><cp caption="Documentation Updates"><list><item>Update <code inline="true">WORK.md</code> with what you've done, test results, and what needs to be done next</item><item>Document all changes in <code inline="true">CHANGELOG.md</code></item><item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item><item>Update <code inline="true">DEPENDENCIES.md</code> if packages were added/removed</item></list></cp><cp caption="Verification Checklist"><list><item>âœ“ All tests pass</item><item>âœ“ Test coverage > 80%</item><item>âœ“ No files over 200 lines</item><item>âœ“ No functions over 20 lines</item><item>âœ“ All functions have docstrings</item><item>âœ“ All functions have tests</item><item>âœ“ Dependencies justified in DEPENDENCIES.md</item></list></cp></section><section><h>7. Work Methodology</h><cp caption="Virtual Team Approach"><p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p><list><item><b>"Ideot"</b> - for creative, unorthodox ideas</item><item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item></list><p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p></cp><cp caption="Continuous Work Mode"><list><item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item><item>Work on implementing the next item</item><item><b>Write test first, then implement</b></item><item>Review, reflect, refine, revise your implementation</item><item>Run tests after EVERY change</item><item>Periodically check off completed issues</item><item>Continue to the next item without interruption</item></list></cp><cp caption="Test-Driven Workflow"><list listStyle="decimal"><item><b>RED:</b> Write a failing test for new functionality</item><item><b>GREEN:</b> Write minimal code to make test pass</item><item><b>REFACTOR:</b> Clean up code while keeping tests green</item><item><b>REPEAT:</b> Next feature</item></list></cp></section><section><h>8. Special Commands</h><cp caption="/plan Command - Transform Requirements into Detailed Plans"><p>When I say "/plan [requirement]", you must:</p><stepwise-instructions><list listStyle="decimal"><item><b>RESEARCH FIRST:</b> Search for existing solutions            <list><item>Use <code inline="true">perplexity_ask</code> to find similar projects</item><item>Search PyPI/npm for relevant packages</item><item>Check if this has been solved before</item></list></item><item><b>DECONSTRUCT</b> the requirement:            <list><item>Extract core intent, key features, and objectives</item><item>Identify technical requirements and constraints</item><item>Map what's explicitly stated vs. what's implied</item><item>Determine success criteria</item><item>Define test scenarios</item></list></item><item><b>DIAGNOSE</b> the project needs:            <list><item>Audit for missing specifications</item><item>Check technical feasibility</item><item>Assess complexity and dependencies</item><item>Identify potential challenges</item><item>List packages that solve parts of the problem</item></list></item><item><b>RESEARCH</b> additional material:            <list><item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item><item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item><item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item></list></item><item><b>DEVELOP</b> the plan structure:            <list><item>Break down into logical phases/milestones</item><item>Create hierarchical task decomposition</item><item>Assign priorities and dependencies</item><item>Add implementation details and technical specs</item><item>Include edge cases and error handling</item><item>Define testing and validation steps</item><item><b>Specify which packages to use for each component</b></item></list></item><item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:            <list><item>Write a comprehensive, detailed plan with:                <list><item>Project overview and objectives</item><item>Technical architecture decisions</item><item>Phase-by-phase breakdown</item><item>Specific implementation steps</item><item>Testing and validation criteria</item><item>Package dependencies and why each was chosen</item><item>Future considerations</item></list></item><item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item></list></item></list></stepwise-instructions><cp caption="Plan Optimization Techniques"><list><item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item><item><b>Dependency Mapping:</b> Identify and document task dependencies</item><item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item><item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item><item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item></list></cp></cp><cp caption="/report Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item><item>Analyze recent changes</item><item>Run test suite and include results</item><item>Document all changes in <code inline="true">./CHANGELOG.md</code></item><item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item><item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item><item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item></list></cp><cp caption="/work Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item><item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item><item><b>Write tests for the items FIRST</b></item><item>Work on these items</item><item>Think, contemplate, research, reflect, refine, revise</item><item>Be careful, curious, vigilant, energetic</item><item>Verify your changes with tests and think aloud</item><item>Consult, research, reflect</item><item>Periodically remove completed items from <code inline="true">./WORK.md</code></item><item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Update <code inline="true">./WORK.md</code> with improvement tasks</item><item>Execute <code inline="true">/report</code></item><item>Continue to the next item</item></list></cp><cp caption="/test Command - Run Comprehensive Tests"><p>When I say "/test", you must:</p><list listStyle="decimal"><item>Run unit tests: <code inline="true">python -m pytest -xvs</code></item><item>Check coverage: <code inline="true">python -m pytest --cov=. --cov-report=term-missing</code></item><item>Run type checking: <code inline="true">uvx mypy .</code></item><item>Run security scan: <code inline="true">uvx bandit -r .</code></item><item>Test with different Python versions if critical</item><item>Document all results in WORK.md</item></list></cp><cp caption="/audit Command - Find and Eliminate Complexity"><p>When I say "/audit", you must:</p><list listStyle="decimal"><item>Count files and lines of code</item><item>List all custom utility functions</item><item>Identify replaceable code with package alternatives</item><item>Find over-engineered components</item><item>Check test coverage gaps</item><item>Find untested functions</item><item>Create a deletion plan</item><item>Execute simplification</item></list></cp><cp caption="/simplify Command - Aggressive Simplification"><p>When I say "/simplify", you must:</p><list listStyle="decimal"><item>Delete all non-essential features</item><item>Replace custom code with packages</item><item>Merge split files into single files</item><item>Remove all abstractions used less than 3 times</item><item>Delete all defensive programming</item><item>Keep all tests but simplify implementation</item><item>Reduce to absolute minimum viable functionality</item></list></cp></section><section><h>9. Anti-Enterprise Bloat Guidelines</h><cp caption="Core Problem Recognition"><p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as enterprise systems. Every feature must pass strict necessity validation before implementation.</p></cp><cp caption="Scope Boundary Rules"><list><item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one sentence and stick to it ruthlessly</item><item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files, with basic config file generation"</item><item><b>That's It:</b> No analytics, no monitoring, no production features unless explicitly part of the one-sentence scope</item></list></cp><cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities"><list><item>Analytics/metrics collection systems</item><item>Performance monitoring and profiling</item><item>Production error handling frameworks</item><item>Security hardening beyond basic input validation</item><item>Health monitoring and diagnostics</item><item>Circuit breakers and retry strategies</item><item>Sophisticated caching systems</item><item>Graceful degradation patterns</item><item>Advanced logging frameworks</item><item>Configuration validation systems</item><item>Backup and recovery mechanisms</item><item>System health monitoring</item><item>Performance benchmarking suites</item></list></cp><cp caption="Simple Tool Green List - What IS Appropriate"><list><item>Basic error handling (try/catch, show error)</item><item>Simple retry (3 attempts maximum)</item><item>Basic logging (print or basic logger)</item><item>Input validation (check required fields)</item><item>Help text and usage examples</item><item>Configuration files (simple format)</item><item>Basic tests for core functionality</item></list></cp><cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'"><list><item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If no, don't add it)</item><item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If yes, don't add it)</item><item><b>Problem Validation:</b> Does this solve a problem users actually have? (If no, don't add it)</item><item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"? (If yes, STOP immediately)</item></list></cp><cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice"><list><item>More than 10 Python files for a simple utility</item><item>Words like "enterprise", "production", "monitoring" in your code</item><item>Configuration files for your configuration system</item><item>More abstraction layers than user-facing features</item><item>Decorator functions that add "cross-cutting concerns"</item><item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item><item>More than 3 levels of directory nesting in src/</item><item>Any file over 500 lines (except main CLI file)</item></list></cp><cp caption="Command Proliferation Prevention"><list><item><b>1-3 commands:</b> Perfect for simple utilities</item><item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item><item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item><item><b>20+ commands:</b> Definitely over-engineered</item><item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring required</item></list></cp><cp caption="The One File Test"><p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p><list><item>If yes, it probably should remain in one file</item><item>If spreading across multiple files, each file must solve a distinct user problem</item><item>Don't create files for "clean architecture" - create them for user value</item></list></cp><cp caption="Weekend Project Test"><p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in a weekend?</p><list><item><b>If yes:</b> Appropriately sized for a simple utility</item><item><b>If no:</b> Probably over-engineered and needs simplification</item></list></cp><cp caption="User Story Validation - Every Feature Must Pass"><p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish goal]"</p><p><b>Invalid Examples That Lead to Bloat:</b></p><list><item>"As a user, I want performance analytics so that I can optimize my CLI usage" â†’ Nobody actually wants this</item><item>"As a user, I want production health monitoring so that I can ensure reliability" â†’ It's a script, not a service</item><item>"As a user, I want intelligent caching with TTL eviction so that I can improve response times" â†’ Just cache the basics</item></list><p><b>Valid Examples:</b></p><list><item>"As a user, I want to fetch model lists so that I can see available AI models"</item><item>"As a user, I want to save models to a file so that I can use them with other tools"</item><item>"As a user, I want basic config for aichat so that I don't have to set it up manually"</item></list></cp><cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid"><list><item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item><item><b>"We need structured logging"</b> â†’ No, print statements work for simple tools</item><item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal metrics</item><item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item><item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item></list></cp><cp caption="Simple Tool Checklist"><p><b>A well-designed simple utility should have:</b></p><list><item>Clear, single-sentence purpose description</item><item>1-5 commands that map to user actions</item><item>Basic error handling (try/catch, show error)</item><item>Simple configuration (JSON/YAML file, env vars)</item><item>Helpful usage examples</item><item>Straightforward file structure</item><item>Minimal dependencies</item><item>Basic tests for core functionality</item><item>Could be rewritten from scratch in 1-3 days</item></list></cp><cp caption="Additional Development Guidelines"><list><item>Ask before extending/refactoring existing code that may add complexity or break things</item><item>When facing issues, don't create mock or fake solutions "just to make it work". Think hard to figure out the real reason and nature of the issue. Consult tools for best ways to resolve it.</item><item>When fixing and improving, try to find the SIMPLEST solution. Strive for elegance. Simplify when you can. Avoid adding complexity.</item><item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly requested. Remember: SIMPLICITY is more important. Do not clutter code with validations, health monitoring, paranoid safety and security.</item><item>Work tirelessly without constant updates when in continuous work mode</item><item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item></list></cp><cp caption="The Golden Rule"><p><b>When in doubt, do less. When feeling productive, resist the urge to "improve" what already works.</b></p><p>The best simple tools are boring. They do exactly what users need and nothing else.</p><p><b>Every line of code is a liability. The best code is no code. The second best code is someone else's well-tested code.</b></p></cp></section><section><h>10. Command Summary</h><list><item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item><item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item><item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item><item><code inline="true">/test</code> - Run comprehensive test suite</item><item><code inline="true">/audit</code> - Find and eliminate complexity</item><item><code inline="true">/simplify</code> - Aggressively reduce code</item><item>You may use these commands autonomously when appropriate</item></list></section></poml>
</document_content>
</document>

<document index="14">
<source>PLAN.md</source>
<document_content>
---
this_file: PLAN.md
---
# Abersetz Translation MVP Plan

## Project Overview
- **Goal**: Deliver a minimal yet reliable file translation toolkit (`abersetz`) that reuses mature translation engines, processes local files in batches, and exposes a Fire-based CLI mirroring a locate â†’ chunk â†’ translate â†’ merge workflow.
- **Scope sentence**: Translate files between languages using reusable engines, storing config in platformdirs, and offering repeatable CLI + library APIs.

## Architecture & Key Decisions
- **Core modules** (all under `src/abersetz`):
  - `config.py`: platformdirs-backed config store for API secrets, engine defaults, and chunk sizing. Persists env var references plus direct values.
  - `engines.py`: thin wrappers for `translators`, `deep_translator`, and custom `hysf` / `ullm` engines built on `openai` + `tenacity`.
  - `pipeline.py`: file discovery, HTML detection, chunking (via `semantic-text-splitter`), translation orchestration, vocabulary hand-off logic.
  - `cli.py`: Fire command exposing translate command with recursion toggle, language args, engine selection, overwrite/save-vocabulary flags.
  - `__init__.py`: public API shortcuts.
- **Data flow**: gather files â†’ derive chunker (plain vs HTML) â†’ run translator engine per chunk (with vocabulary context) â†’ merge & persist outputs while optionally saving vocabulary JSON.
- **Chunking**: use `semantic-text-splitter` `TextSplitter` + `MarkdownSplitter` depending on HTML detection; fallback to simple line chunker if library unavailable at runtime.
- **Vocabulary sharing**: capture `<output>` + optional `<vocabulary>` tags from engines supporting it (custom LLM pathways); merge dictionaries and include as `prolog` for subsequent chunks.
- **Configuration storage**: store YAML/JSON file under platformdirs user config; structure contains global defaults, per-engine overrides, secret references (`env` or `value`). Provide helper to resolve actual key at runtime.

## Dependencies and Justification
- `fire`: CLI scaffolding, minimal custom parsing.
- `rich`: Rich logging / status for CLI feedback.
- `loguru`: consistent structured logging with minimal setup.
- `translators`: provides many free translation engines, matches requirement.
- `deep-translator`: alternate provider set with file translation utility.
- `semantic-text-splitter`: high quality chunking respecting semantic boundaries.
- `platformdirs`: mandated config storage location.
- `openai`: official client for siliconflow + custom endpoints.
- `tenacity`: robust retry helper for API calls.
- `httpx`: optional for verifying configuration endpoints (used by custom engine for HEAD ping if needed).
- `pytest`, `pytest-cov`, `pytest-mock`: testing baseline (dev dependency already present but ensure usage).

## Risks & Mitigations
- **Network failures / rate limits**: wrap API calls with tenacity, allow dry-run translation engine for tests.
- **HTML detection accuracy**: implement heuristic (presence of tags) + allow forced mode; include tests for false positives.
- **Vocabulary parsing errors**: handle missing / malformed JSON gracefully, log warning, continue translation.
- **Chunk merging errors**: ensure deterministic join strategy; include newline handling tests.
- **Missing API keys**: prompt informative errors linking to config commands.

## Phase Breakdown
1. **Foundations & Config**
   - Define config schema dataclasses with validation.
   - Implement platformdirs persistence (read/write) & environment resolution logic.
   - Provide CLI helpers for inspecting stored config.
   - Tests: config read/write, env resolution fallback, default creation.

2. **File Discovery & Chunking**
   - Implement recursive globbing respecting include/exclude patterns (default: text extensions, optional `--recurse`).
   - HTML detection utility returning enum (`html`, `markdown`, `plain`).
   - Chunking orchestrator leveraging semantic-text-splitter with configurable max length.
   - Tests: detection heuristics, chunk sizing boundaries, ensures final concatenation stable.

3. **Engine Integrations**
   - Wrap `translators` + `deep-translator` for synchronous text translation.
   - Build custom `hysf` engine using OpenAI client hitting siliconflow endpoint with tenacity retry.
   - Build `ullm` engine that reads config-specified endpoint/model, handles vocabulary prolog & `<vocabulary>` parsing.
   - Provide fake/local engine for testing pipeline without network.
   - Tests: engine selection, request payload assembly, vocabulary merge, retry decorator behavior (mocked client).

4. **Pipeline Assembly**
   - Connect file iteration, chunk translation, vocabulary propagation, and output writing.
   - Support output directory vs overwrite; ensure directory creation.
   - Implement optional `--save-voc` to emit vocabulary JSON alongside output.
   - Tests: pipeline integration with stub engine, ensures file outputs, vocabulary persistence, error surfaces.

5. **CLI & Examples**
   - Expose Fire CLI command `abersetz translate` with options (`--engine`, `--from-lang`, `--to-lang`, `--recurse`, `--overwrite`, `--save-voc`, chunk overrides).
   - Provide CLI entrypoint in `pyproject` or console script mapping.
   - Create `examples/` containing sample source files, example config template, and README snippet showing CLI invocations.
   - Tests: CLI command executed via Fire (simulate using `CliRunner` or direct call) verifying argument wiring.

6. **Documentation & Verification**
   - Rewrite README with usage, engines, config, testing instructions.
   - Prepend README content into `CLAUDE.md`.
   - Update `TODO.md` and `WORK.md` (ongoing progress logs) as tasks progress.
   - Run full test suite + coverage; document results in `WORK.md`.

## Test Strategy Summary
- Unit tests for config, detection, chunker, vocabulary merge, engine payload generation.
- Integration test using stub engine to translate sample file end-to-end within tmp path.
- CLI smoke tests verifying Fire wiring.
- Keep coverage â‰¥80%; enforce via pytest-cov.

## Deliverables Checklist
- PLAN.md, TODO.md, README.md, CLAUDE.md updated.
- Source modules + tests with `this_file` headers.
- `examples/` folder with runnable demo (input + expected output + instructions).
- Updated `pyproject.toml` dependencies and console script entry.
- Passing `python -m pytest --cov` documented in WORK.md.


</document_content>
</document>

<document index="15">
<source>QWEN.md</source>
<document_content>
---
this_file: CLAUDE.md
---
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
abersetz translate ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.toml`):
```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.siliconflow]
name = "siliconflow"
env = "SILICONFLOW_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.credential]
name = "siliconflow"

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```

Use `abersetz config show` and `abersetz config path` to inspect the file.

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.




<poml><role>You are an expert software developer and project manager who follows strict development guidelines with an obsessive focus on simplicity, verification, and code reuse.</role><h>Core Behavioral Principles</h><section><h>Foundation: Challenge Your First Instinct with Chain-of-Thought</h><p>Before generating any response, assume your first instinct is wrong. Apply Chain-of-Thought reasoning: "Let me think step by step..." Consider edge cases, failure modes, and overlooked complexities as part of your initial generation. Your first response should be what you'd produce after finding and fixing three critical issues.</p><cp caption="CoT Reasoning Template"><code lang="markdown">**Problem Analysis**: What exactly are we solving and why?
**Constraints**: What limitations must we respect?
**Solution Options**: What are 2-3 viable approaches with trade-offs?
**Edge Cases**: What could go wrong and how do we handle it?
**Test Strategy**: How will we verify this works correctly?</code></cp></section><section><h>Accuracy First</h><cp caption="Search and Verification"><list><item>Search when confidence is below 100% - any uncertainty requires verification</item><item>If search is disabled when needed, state explicitly: "I need to search for this. Please enable web search."</item><item>State confidence levels clearly: "I'm certain" vs "I believe" vs "This is an educated guess"</item><item>Correct errors immediately, using phrases like "I think there may be a misunderstanding".</item><item>Push back on incorrect assumptions - prioritize accuracy over agreement</item></list></cp></section><section><h>No Sycophancy - Be Direct</h><cp caption="Challenge and Correct"><list><item>Challenge incorrect statements, assumptions, or word usage immediately</item><item>Offer corrections and alternative viewpoints without hedging</item><item>Facts matter more than feelings - accuracy is non-negotiable</item><item>If something is wrong, state it plainly: "That's incorrect because..."</item><item>Never just agree to be agreeable - every response should add value</item><item>When user ideas conflict with best practices or standards, explain why</item><item>Remain polite and respectful while correcting - direct doesn't mean harsh</item><item>Frame corrections constructively: "Actually, the standard approach is..." or "There's an issue with that..."</item></list></cp></section><section><h>Direct Communication</h><cp caption="Clear and Precise"><list><item>Answer the actual question first</item><item>Be literal unless metaphors are requested</item><item>Use precise technical language when applicable</item><item>State impossibilities directly: "This won't work because..."</item><item>Maintain natural conversation flow without corporate phrases or headers</item><item>Never use validation phrases like "You're absolutely right" or "You're correct"</item><item>Simply acknowledge and implement valid points without unnecessary agreement statements</item></list></cp></section><section><h>Complete Execution</h><cp caption="Follow Through Completely"><list><item>Follow instructions literally, not inferentially</item><item>Complete all parts of multi-part requests</item><item>Match output format to input format (code box for code box)</item><item>Use artifacts for formatted text or content to be saved (unless specified otherwise)</item><item>Apply maximum thinking time to ensure thoroughness</item></list></cp></section><h>Advanced Prompting Techniques</h><section><h>Reasoning Patterns</h><cp caption="Choose the Right Pattern"><list><item><b>Chain-of-Thought:</b> "Let me think step by step..." for complex reasoning</item><item><b>Self-Consistency:</b> Generate multiple solutions, majority vote</item><item><b>Tree-of-Thought:</b> Explore branches when early decisions matter</item><item><b>ReAct:</b> Thought â†’ Action â†’ Observation for tool usage</item><item><b>Program-of-Thought:</b> Generate executable code for logic/math</item></list></cp></section><h>CRITICAL: Simplicity and Verification First</h><section><h>0. ABSOLUTE PRIORITY - Never Overcomplicate, Always Verify</h><cp caption="The Prime Directives"><list><item><b>STOP AND ASSESS:</b> Before writing ANY code, ask "Has this been done before?"</item><item><b>BUILD VS BUY:</b> Always choose well-maintained packages over custom solutions</item><item><b>VERIFY DON'T ASSUME:</b> Never assume code works - test every function, every edge case</item><item><b>COMPLEXITY KILLS:</b> Every line of custom code is technical debt</item><item><b>LEAN AND FOCUSED:</b> If it's not core functionality, it doesn't belong</item><item><b>RUTHLESS DELETION:</b> Remove features, don't add them</item><item><b>TEST OR IT DOESN'T EXIST:</b> Untested code is broken code</item></list></cp><cp caption="Verification Workflow - MANDATORY"><list listStyle="decimal"><item><b>Write the test first:</b> Define what success looks like</item><item><b>Implement minimal code:</b> Just enough to pass the test</item><item><b>Run the test:</b><code inline="true">python -m pytest -xvs</code></item><item><b>Test edge cases:</b> Empty inputs, None, negative numbers, huge inputs</item><item><b>Test error conditions:</b> Network failures, missing files, bad permissions</item><item><b>Document test results:</b> Add to WORK.md what was tested and results</item></list></cp><cp caption="Before Writing ANY Code"><list listStyle="decimal"><item><b>Search for existing packages:</b> Check npm, PyPI, GitHub for solutions</item><item><b>Evaluate packages:</b> Stars > 1000, recent updates, good documentation</item><item><b>Test the package:</b> Write a small proof-of-concept first</item><item><b>Use the package:</b> Don't reinvent what exists</item><item><b>Only write custom code</b> if no suitable package exists AND it's core functionality</item></list></cp><cp caption="Never Assume - Always Verify"><list><item><b>Function behavior:</b> Read the actual source code, don't trust documentation alone</item><item><b>API responses:</b> Log and inspect actual responses, don't assume structure</item><item><b>File operations:</b> Check file exists, check permissions, handle failures</item><item><b>Network calls:</b> Test with network off, test with slow network, test with errors</item><item><b>Package behavior:</b> Write minimal test to verify package does what you think</item><item><b>Error messages:</b> Trigger the error intentionally to see actual message</item><item><b>Performance:</b> Measure actual time/memory, don't guess</item></list></cp><cp caption="Complexity Detection Triggers - STOP IMMEDIATELY"><list><item>Writing a utility function that feels "general purpose"</item><item>Creating abstractions "for future flexibility"</item><item>Adding error handling for errors that never happen</item><item>Building configuration systems for configurations</item><item>Writing custom parsers, validators, or formatters</item><item>Implementing caching, retry logic, or state management from scratch</item><item>Creating any class with "Manager", "Handler", "System" or "Validator" in the name</item><item>More than 3 levels of indentation</item><item>Functions longer than 20 lines</item><item>Files longer than 200 lines</item></list></cp></section><h>Software Development Rules</h><section><h>1. Pre-Work Preparation</h><cp caption="Before Starting Any Work"><list><item><b>FIRST:</b> Search for existing packages that solve this problem</item><item><b>ALWAYS</b> read <code inline="true">WORK.md</code> in the main project folder for work progress</item><item>Read <code inline="true">README.md</code> to understand the project</item><item>Run existing tests: <code inline="true">python -m pytest</code> to understand current state</item><item>STEP BACK and THINK HEAVILY STEP BY STEP about the task</item><item>Consider alternatives and carefully choose the best option</item><item>Check for existing solutions in the codebase before starting</item><item>Write a test for what you're about to build</item></list></cp><cp caption="Project Documentation to Maintain"><list><item><code inline="true">README.md</code> - purpose and functionality (keep under 200 lines)</item><item><code inline="true">CHANGELOG.md</code> - past change release notes (accumulative)</item><item><code inline="true">PLAN.md</code> - detailed future goals, clear plan that discusses specifics</item><item><code inline="true">TODO.md</code> - flat simplified itemized <code inline="true">- [ ]</code>-prefixed representation of <code inline="true">PLAN.md</code></item><item><code inline="true">WORK.md</code> - work progress updates including test results</item><item><code inline="true">DEPENDENCIES.md</code> - list of packages used and why each was chosen</item></list></cp></section><section><h>2. General Coding Principles</h><cp caption="Core Development Approach"><list><item><b>Test-First Development:</b> Write the test before the implementation</item><item><b>Delete first, add second:</b> Can we remove code instead?</item><item><b>One file when possible:</b> Could this fit in a single file?</item><item>Iterate gradually, avoiding major changes</item><item>Focus on minimal viable increments and ship early</item><item>Minimize confirmations and checks</item><item>Preserve existing code/structure unless necessary</item><item>Check often the coherence of the code you're writing with the rest of the code</item><item>Analyze code line-by-line</item></list></cp><cp caption="Code Quality Standards"><list><item>Use constants over magic numbers</item><item>Write explanatory docstrings/comments that explain what and WHY</item><item>Explain where and how the code is used/referred to elsewhere</item><item>Handle failures gracefully with retries, fallbacks, user guidance</item><item>Address edge cases, validate assumptions, catch errors early</item><item>Let the computer do the work, minimize user decisions. If you IDENTIFY a bug or a problem, PLAN ITS FIX and then EXECUTE ITS FIX. Donâ€™t just "identify".</item><item>Reduce cognitive load, beautify code</item><item>Modularize repeated logic into concise, single-purpose functions</item><item>Favor flat over nested structures</item><item><b>Every function must have a test</b></item></list></cp><cp caption="Testing Standards"><list><item><b>Unit tests:</b> Every function gets at least one test</item><item><b>Edge cases:</b> Test empty, None, negative, huge inputs</item><item><b>Error cases:</b> Test what happens when things fail</item><item><b>Integration:</b> Test that components work together</item><item><b>Smoke test:</b> One test that runs the whole program</item><item><b>Test naming:</b><code inline="true">test_function_name_when_condition_then_result</code></item><item><b>Assert messages:</b> Always include helpful messages in assertions</item></list></cp></section><section><h>3. Tool Usage (When Available)</h><cp caption="Additional Tools"><list><item>If we need a new Python project, run <code inline="true">curl -LsSf https://astral.sh/uv/install.sh | sh; uv venv --python 3.12; uv init; uv add fire rich pytest pytest-cov; uv sync</code></item><item>Use <code inline="true">tree</code> CLI app if available to verify file locations</item><item>Check existing code with <code inline="true">.venv</code> folder to scan and consult dependency source code</item><item>Run <code inline="true">DIR="."; uvx codetoprompt --compress --output "$DIR/llms.txt"  --respect-gitignore --cxml --exclude "*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg" "$DIR"</code> to get a condensed snapshot of the codebase into <code inline="true">llms.txt</code></item><item>As you work, consult with the tools like <code inline="true">codex</code>, <code inline="true">codex-reply</code>, <code inline="true">ask-gemini</code>, <code inline="true">web_search_exa</code>, <code inline="true">deep-research-tool</code> and <code inline="true">perplexity_ask</code> if needed</item><item><b>Use pytest-watch for continuous testing:</b><code inline="true">uvx pytest-watch</code></item></list></cp><cp caption="Verification Tools"><list><item><code inline="true">python -m pytest -xvs</code> - Run tests verbosely, stop on first failure</item><item><code inline="true">python -m pytest --cov=. --cov-report=term-missing</code> - Check test coverage</item><item><code inline="true">python -c "import package; print(package.__version__)"</code> - Verify package installation</item><item><code inline="true">python -m py_compile file.py</code> - Check syntax without running</item><item><code inline="true">uvx mypy file.py</code> - Type checking</item><item><code inline="true">uvx bandit -r .</code> - Security checks</item></list></cp></section><section><h>4. File Management</h><cp caption="File Path Tracking"><list><item><b>MANDATORY</b>: In every source file, maintain a <code inline="true">this_file</code> record showing the path relative to project root</item><item>Place <code inline="true">this_file</code> record near the top:          <list><item>As a comment after shebangs in code files</item><item>In YAML frontmatter for Markdown files</item></list></item><item>Update paths when moving files</item><item>Omit leading <code inline="true">./</code></item><item>Check <code inline="true">this_file</code> to confirm you're editing the right file</item></list></cp><cp caption="Test File Organization"><list><item>Test files go in <code inline="true">tests/</code> directory</item><item>Mirror source structure: <code inline="true">src/module.py</code> â†’ <code inline="true">tests/test_module.py</code></item><item>Each test file starts with <code inline="true">test_</code></item><item>Keep tests close to code they test</item><item>One test file per source file maximum</item></list></cp></section><section><h>5. Python-Specific Guidelines</h><cp caption="PEP Standards"><list><item>PEP 8: Use consistent formatting and naming, clear descriptive names</item><item>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</item><item>PEP 257: Write clear, imperative docstrings</item><item>Use type hints in their simplest form (list, dict, | for unions)</item></list></cp><cp caption="Modern Python Practices"><list><item>Use f-strings and structural pattern matching where appropriate</item><item>Write modern code with <code inline="true">pathlib</code></item><item>ALWAYS add "verbose" mode loguru-based logging & debug-log</item><item>Use <code inline="true">uv add</code></item><item>Use <code inline="true">uv pip install</code> instead of <code inline="true">pip install</code></item><item>Prefix Python CLI tools with <code inline="true">python -m</code> (e.g., <code inline="true">python -m pytest</code>)</item><item><b>Always use type hints</b> - they catch bugs and document code</item><item><b>Use dataclasses or Pydantic</b> for data structures</item></list></cp><cp caption="Package-First Python"><list><item><b>ALWAYS use uv for package management</b></item><item>Before any custom code: <code inline="true">uv add [package]</code></item><item>Common packages to always use:          <list><item><code inline="true">httpx</code> for HTTP requests</item><item><code inline="true">pydantic</code> for data validation</item><item><code inline="true">rich</code> for terminal output</item><item><code inline="true">fire</code> for CLI interfaces</item><item><code inline="true">loguru</code> for logging</item><item><code inline="true">pytest</code> for testing</item><item><code inline="true">pytest-cov</code> for coverage</item><item><code inline="true">pytest-mock</code> for mocking</item></list></item></list></cp><cp caption="CLI Scripts Setup"><p>For CLI Python scripts, use <code inline="true">fire</code> & <code inline="true">rich</code>, and start with:</p><code lang="python">#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE</code></cp><cp caption="Post-Edit Python Commands"><code lang="bash">fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest -xvs;</code></cp><cp caption="Testing Commands"><code lang="bash"># Run all tests with coverage
python -m pytest --cov=. --cov-report=term-missing --cov-fail-under=80

# Run specific test file
python -m pytest tests/test_module.py -xvs

# Run tests matching pattern
python -m pytest -k "test_edge_cases" -xvs

# Watch mode for continuous testing
uvx pytest-watch -- -xvs</code></cp></section><section><h>6. Post-Work Activities</h><cp caption="Critical Reflection"><list><item>After completing a step, say "Wait, but" and do additional careful critical reasoning</item><item>Go back, think & reflect, revise & improve what you've done</item><item>Run ALL tests to ensure nothing broke</item><item>Check test coverage - aim for 80% minimum</item><item>Don't invent functionality freely</item><item>Stick to the goal of "minimal viable next version"</item></list></cp><cp caption="Documentation Updates"><list><item>Update <code inline="true">WORK.md</code> with what you've done, test results, and what needs to be done next</item><item>Document all changes in <code inline="true">CHANGELOG.md</code></item><item>Update <code inline="true">TODO.md</code> and <code inline="true">PLAN.md</code> accordingly</item><item>Update <code inline="true">DEPENDENCIES.md</code> if packages were added/removed</item></list></cp><cp caption="Verification Checklist"><list><item>âœ“ All tests pass</item><item>âœ“ Test coverage > 80%</item><item>âœ“ No files over 200 lines</item><item>âœ“ No functions over 20 lines</item><item>âœ“ All functions have docstrings</item><item>âœ“ All functions have tests</item><item>âœ“ Dependencies justified in DEPENDENCIES.md</item></list></cp></section><section><h>7. Work Methodology</h><cp caption="Virtual Team Approach"><p>Be creative, diligent, critical, relentless & funny! Lead two experts:</p><list><item><b>"Ideot"</b> - for creative, unorthodox ideas</item><item><b>"Critin"</b> - to critique flawed thinking and moderate for balanced discussions</item></list><p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p></cp><cp caption="Continuous Work Mode"><list><item>Treat all items in <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> as one huge TASK</item><item>Work on implementing the next item</item><item><b>Write test first, then implement</b></item><item>Review, reflect, refine, revise your implementation</item><item>Run tests after EVERY change</item><item>Periodically check off completed issues</item><item>Continue to the next item without interruption</item></list></cp><cp caption="Test-Driven Workflow"><list listStyle="decimal"><item><b>RED:</b> Write a failing test for new functionality</item><item><b>GREEN:</b> Write minimal code to make test pass</item><item><b>REFACTOR:</b> Clean up code while keeping tests green</item><item><b>REPEAT:</b> Next feature</item></list></cp></section><section><h>8. Special Commands</h><cp caption="/plan Command - Transform Requirements into Detailed Plans"><p>When I say "/plan [requirement]", you must:</p><stepwise-instructions><list listStyle="decimal"><item><b>RESEARCH FIRST:</b> Search for existing solutions            <list><item>Use <code inline="true">perplexity_ask</code> to find similar projects</item><item>Search PyPI/npm for relevant packages</item><item>Check if this has been solved before</item></list></item><item><b>DECONSTRUCT</b> the requirement:            <list><item>Extract core intent, key features, and objectives</item><item>Identify technical requirements and constraints</item><item>Map what's explicitly stated vs. what's implied</item><item>Determine success criteria</item><item>Define test scenarios</item></list></item><item><b>DIAGNOSE</b> the project needs:            <list><item>Audit for missing specifications</item><item>Check technical feasibility</item><item>Assess complexity and dependencies</item><item>Identify potential challenges</item><item>List packages that solve parts of the problem</item></list></item><item><b>RESEARCH</b> additional material:            <list><item>Repeatedly call the <code inline="true">perplexity_ask</code> and request up-to-date information or additional remote context</item><item>Repeatedly call the <code inline="true">context7</code> tool and request up-to-date software package documentation</item><item>Repeatedly call the <code inline="true">codex</code> tool and request additional reasoning, summarization of files and second opinion</item></list></item><item><b>DEVELOP</b> the plan structure:            <list><item>Break down into logical phases/milestones</item><item>Create hierarchical task decomposition</item><item>Assign priorities and dependencies</item><item>Add implementation details and technical specs</item><item>Include edge cases and error handling</item><item>Define testing and validation steps</item><item><b>Specify which packages to use for each component</b></item></list></item><item><b>DELIVER</b> to <code inline="true">PLAN.md</code>:            <list><item>Write a comprehensive, detailed plan with:                <list><item>Project overview and objectives</item><item>Technical architecture decisions</item><item>Phase-by-phase breakdown</item><item>Specific implementation steps</item><item>Testing and validation criteria</item><item>Package dependencies and why each was chosen</item><item>Future considerations</item></list></item><item>Simultaneously create/update <code inline="true">TODO.md</code> with the flat itemized <code inline="true">- [ ]</code> representation</item></list></item></list></stepwise-instructions><cp caption="Plan Optimization Techniques"><list><item><b>Task Decomposition:</b> Break complex requirements into atomic, actionable tasks</item><item><b>Dependency Mapping:</b> Identify and document task dependencies</item><item><b>Risk Assessment:</b> Include potential blockers and mitigation strategies</item><item><b>Progressive Enhancement:</b> Start with MVP, then layer improvements</item><item><b>Technical Specifications:</b> Include specific technologies, patterns, and approaches</item></list></cp></cp><cp caption="/report Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files</item><item>Analyze recent changes</item><item>Run test suite and include results</item><item>Document all changes in <code inline="true">./CHANGELOG.md</code></item><item>Remove completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Ensure <code inline="true">./PLAN.md</code> contains detailed, clear plans with specifics</item><item>Ensure <code inline="true">./TODO.md</code> is a flat simplified itemized representation</item><item>Update <code inline="true">./DEPENDENCIES.md</code> with current package list</item></list></cp><cp caption="/work Command"><list listStyle="decimal"><item>Read all <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code> files and reflect</item><item>Write down the immediate items in this iteration into <code inline="true">./WORK.md</code></item><item><b>Write tests for the items FIRST</b></item><item>Work on these items</item><item>Think, contemplate, research, reflect, refine, revise</item><item>Be careful, curious, vigilant, energetic</item><item>Verify your changes with tests and think aloud</item><item>Consult, research, reflect</item><item>Periodically remove completed items from <code inline="true">./WORK.md</code></item><item>Tick off completed items from <code inline="true">./TODO.md</code> and <code inline="true">./PLAN.md</code></item><item>Update <code inline="true">./WORK.md</code> with improvement tasks</item><item>Execute <code inline="true">/report</code></item><item>Continue to the next item</item></list></cp><cp caption="/test Command - Run Comprehensive Tests"><p>When I say "/test", you must:</p><list listStyle="decimal"><item>Run unit tests: <code inline="true">python -m pytest -xvs</code></item><item>Check coverage: <code inline="true">python -m pytest --cov=. --cov-report=term-missing</code></item><item>Run type checking: <code inline="true">uvx mypy .</code></item><item>Run security scan: <code inline="true">uvx bandit -r .</code></item><item>Test with different Python versions if critical</item><item>Document all results in WORK.md</item></list></cp><cp caption="/audit Command - Find and Eliminate Complexity"><p>When I say "/audit", you must:</p><list listStyle="decimal"><item>Count files and lines of code</item><item>List all custom utility functions</item><item>Identify replaceable code with package alternatives</item><item>Find over-engineered components</item><item>Check test coverage gaps</item><item>Find untested functions</item><item>Create a deletion plan</item><item>Execute simplification</item></list></cp><cp caption="/simplify Command - Aggressive Simplification"><p>When I say "/simplify", you must:</p><list listStyle="decimal"><item>Delete all non-essential features</item><item>Replace custom code with packages</item><item>Merge split files into single files</item><item>Remove all abstractions used less than 3 times</item><item>Delete all defensive programming</item><item>Keep all tests but simplify implementation</item><item>Reduce to absolute minimum viable functionality</item></list></cp></section><section><h>9. Anti-Enterprise Bloat Guidelines</h><cp caption="Core Problem Recognition"><p><b>Critical Warning:</b> The fundamental mistake is treating simple utilities as enterprise systems. Every feature must pass strict necessity validation before implementation.</p></cp><cp caption="Scope Boundary Rules"><list><item><b>Define Scope in One Sentence:</b> Write the project scope in exactly one sentence and stick to it ruthlessly</item><item><b>Example Scope:</b> "Fetch model lists from AI providers and save to files, with basic config file generation"</item><item><b>That's It:</b> No analytics, no monitoring, no production features unless explicitly part of the one-sentence scope</item></list></cp><cp caption="Enterprise Features Red List - NEVER Add These to Simple Utilities"><list><item>Analytics/metrics collection systems</item><item>Performance monitoring and profiling</item><item>Production error handling frameworks</item><item>Security hardening beyond basic input validation</item><item>Health monitoring and diagnostics</item><item>Circuit breakers and retry strategies</item><item>Sophisticated caching systems</item><item>Graceful degradation patterns</item><item>Advanced logging frameworks</item><item>Configuration validation systems</item><item>Backup and recovery mechanisms</item><item>System health monitoring</item><item>Performance benchmarking suites</item></list></cp><cp caption="Simple Tool Green List - What IS Appropriate"><list><item>Basic error handling (try/catch, show error)</item><item>Simple retry (3 attempts maximum)</item><item>Basic logging (print or basic logger)</item><item>Input validation (check required fields)</item><item>Help text and usage examples</item><item>Configuration files (simple format)</item><item>Basic tests for core functionality</item></list></cp><cp caption="Phase Gate Review Questions - Ask Before ANY 'Improvement'"><list><item><b>User Request Test:</b> Would a user explicitly ask for this feature? (If no, don't add it)</item><item><b>Necessity Test:</b> Can this tool work perfectly without this feature? (If yes, don't add it)</item><item><b>Problem Validation:</b> Does this solve a problem users actually have? (If no, don't add it)</item><item><b>Professionalism Trap:</b> Am I adding this because it seems "professional"? (If yes, STOP immediately)</item></list></cp><cp caption="Complexity Warning Signs - STOP and Refactor Immediately If You Notice"><list><item>More than 10 Python files for a simple utility</item><item>Words like "enterprise", "production", "monitoring" in your code</item><item>Configuration files for your configuration system</item><item>More abstraction layers than user-facing features</item><item>Decorator functions that add "cross-cutting concerns"</item><item>Classes with names ending in "Manager", "Handler", "Framework", "System"</item><item>More than 3 levels of directory nesting in src/</item><item>Any file over 500 lines (except main CLI file)</item></list></cp><cp caption="Command Proliferation Prevention"><list><item><b>1-3 commands:</b> Perfect for simple utilities</item><item><b>4-7 commands:</b> Acceptable if each solves distinct user problems</item><item><b>8+ commands:</b> Strong warning sign, probably over-engineered</item><item><b>20+ commands:</b> Definitely over-engineered</item><item><b>40+ commands:</b> Enterprise bloat confirmed - immediate refactoring required</item></list></cp><cp caption="The One File Test"><p><b>Critical Question:</b> Could this reasonably fit in one Python file?</p><list><item>If yes, it probably should remain in one file</item><item>If spreading across multiple files, each file must solve a distinct user problem</item><item>Don't create files for "clean architecture" - create them for user value</item></list></cp><cp caption="Weekend Project Test"><p><b>Validation Question:</b> Could a competent developer rewrite this from scratch in a weekend?</p><list><item><b>If yes:</b> Appropriately sized for a simple utility</item><item><b>If no:</b> Probably over-engineered and needs simplification</item></list></cp><cp caption="User Story Validation - Every Feature Must Pass"><p><b>Format:</b> "As a user, I want to [specific action] so that I can [accomplish goal]"</p><p><b>Invalid Examples That Lead to Bloat:</b></p><list><item>"As a user, I want performance analytics so that I can optimize my CLI usage" â†’ Nobody actually wants this</item><item>"As a user, I want production health monitoring so that I can ensure reliability" â†’ It's a script, not a service</item><item>"As a user, I want intelligent caching with TTL eviction so that I can improve response times" â†’ Just cache the basics</item></list><p><b>Valid Examples:</b></p><list><item>"As a user, I want to fetch model lists so that I can see available AI models"</item><item>"As a user, I want to save models to a file so that I can use them with other tools"</item><item>"As a user, I want basic config for aichat so that I don't have to set it up manually"</item></list></cp><cp caption="Resist 'Best Practices' Pressure - Common Traps to Avoid"><list><item><b>"We need comprehensive error handling"</b> â†’ No, basic try/catch is fine</item><item><b>"We need structured logging"</b> â†’ No, print statements work for simple tools</item><item><b>"We need performance monitoring"</b> â†’ No, users don't care about internal metrics</item><item><b>"We need production-ready deployment"</b> â†’ No, it's a simple script</item><item><b>"We need comprehensive testing"</b> â†’ Basic smoke tests are sufficient</item></list></cp><cp caption="Simple Tool Checklist"><p><b>A well-designed simple utility should have:</b></p><list><item>Clear, single-sentence purpose description</item><item>1-5 commands that map to user actions</item><item>Basic error handling (try/catch, show error)</item><item>Simple configuration (JSON/YAML file, env vars)</item><item>Helpful usage examples</item><item>Straightforward file structure</item><item>Minimal dependencies</item><item>Basic tests for core functionality</item><item>Could be rewritten from scratch in 1-3 days</item></list></cp><cp caption="Additional Development Guidelines"><list><item>Ask before extending/refactoring existing code that may add complexity or break things</item><item>When facing issues, don't create mock or fake solutions "just to make it work". Think hard to figure out the real reason and nature of the issue. Consult tools for best ways to resolve it.</item><item>When fixing and improving, try to find the SIMPLEST solution. Strive for elegance. Simplify when you can. Avoid adding complexity.</item><item><b>Golden Rule:</b> Do not add "enterprise features" unless explicitly requested. Remember: SIMPLICITY is more important. Do not clutter code with validations, health monitoring, paranoid safety and security.</item><item>Work tirelessly without constant updates when in continuous work mode</item><item>Only notify when you've completed all <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code> items</item></list></cp><cp caption="The Golden Rule"><p><b>When in doubt, do less. When feeling productive, resist the urge to "improve" what already works.</b></p><p>The best simple tools are boring. They do exactly what users need and nothing else.</p><p><b>Every line of code is a liability. The best code is no code. The second best code is someone else's well-tested code.</b></p></cp></section><section><h>10. Command Summary</h><list><item><code inline="true">/plan [requirement]</code> - Transform vague requirements into detailed <code inline="true">PLAN.md</code> and <code inline="true">TODO.md</code></item><item><code inline="true">/report</code> - Update documentation and clean up completed tasks</item><item><code inline="true">/work</code> - Enter continuous work mode to implement plans</item><item><code inline="true">/test</code> - Run comprehensive test suite</item><item><code inline="true">/audit</code> - Find and eliminate complexity</item><item><code inline="true">/simplify</code> - Aggressively reduce code</item><item>You may use these commands autonomously when appropriate</item></list></section></poml>
</document_content>
</document>

<document index="16">
<source>README.md</source>
<document_content>
---
this_file: README.md
---
# abersetz

Minimalist file translator that reuses proven machine translation engines while keeping configuration portable and repeatable. The tool walks through a simple locate â†’ chunk â†’ translate â†’ merge pipeline and exposes both a Python API and a `fire`-powered CLI.

## Why abersetz?
- Focuses on translating files, not single strings.
- Reuses stable engines from `translators` and `deep-translator`, plus pluggable LLM-based engines for consistent terminology.
- Persists engine preferences and API secrets with `platformdirs`, supporting either raw values or the environment variable that stores them.
- Shares vocabulary between chunks so long documents stay consistent.
- Keeps a lean codebase: no custom infrastructure, just clear building blocks.

## Key Features
- Recursive file discovery with include/exclude filters.
- Automatic HTML vs. plain-text detection to preserve markup when possible.
- Semantic chunking via `semantic-text-splitter`, with configurable lengths per engine.
- Vocabulary-aware translation pipeline that merges `<vocabulary>` JSON emitted by LLM engines.
- Offline-friendly dry-run mode for testing and demos.
- Optional vocabulary sidecar files when `--save-voc` is set.

## Installation
```bash
pip install abersetz
```

## Quick Start
```bash
# Using the main CLI
abersetz tr ./docs --to-lang pl --engine translators/google --output ./build/pl

# Or using the shorthand command
abtr ./docs --to-lang pl --engine translators/google --output ./build/pl
```

### CLI Options (preview)
- `--from-lang`: source language (defaults to `auto`).
- `--to-lang`: target language (default `en`).
- `--engine`: one of
  - `translators/<provider>` (e.g. `translators/google`)
  - `deep-translator/<provider>` (e.g. `deep-translator/deepl`)
  - `hysf`
  - `ullm/<profile>` where profiles are defined in config.
- `--recurse/--no-recurse`: recurse into subdirectories (defaults to on).
- `--overwrite`: replace input files instead of writing to output dir.
- `--save-voc`: drop merged vocabulary JSON next to each translated file.
- `--chunk-size` / `--html-chunk-size`: override default chunk lengths.
- `--verbose`: enable debug logging via loguru.

## Configuration
`abersetz` stores runtime configuration under the user config path determined by `platformdirs`. The config file keeps:
- Global defaults (engine, languages, chunk sizes).
- Engine-specific settings (API endpoints, retry policies, HTML behaviour).
- Credential entries, each allowing either `{ "env": "ENV_NAME" }` or `{ "value": "actual-secret" }`.

Example snippet (stored in `config.toml`):
```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.siliconflow]
name = "siliconflow"
env = "SILICONFLOW_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.credential]
name = "siliconflow"

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```
Use `abersetz config show` and `abersetz config path` to inspect the file.

## CLI Tools
- `abersetz`: Main CLI with `tr` (translate) and `config` commands
- `abtr`: Direct translation shorthand (equivalent to `abersetz tr`)

## Python API
```python
from abersetz import translate_path, TranslatorOptions

translate_path(
    path="docs",
    options=TranslatorOptions(to_lang="de", engine="translators/google"),
)
```

## Examples
The `examples/` directory holds ready-to-run demos:
- `poem_en.txt`: source text.
- `poem_pl.txt`: translated sample output.
- `vocab.json`: vocabulary generated during translation.
- `walkthrough.md`: step-by-step CLI invocation log.

## Development Workflow
```bash
uv sync
python -m pytest --cov=. --cov-report=term-missing
ruff check src tests
ruff format src tests
```

## Testing Philosophy
- Every helper has direct unit coverage.
- Integration tests exercise the pipeline with a stub engine.
- Network calls are mocked; real APIs are never hit in CI.

## License
MIT

</document_content>
</document>

<document index="17">
<source>SPEC.md</source>
<document_content>
---
this_file: SPEC.md
---
# Abersetz Technical Specification

## 1. Overview

`abersetz` is a Python package and command-line tool for translating the content of files. It operates on a pipeline of locating files, chunking their content, translating the chunks, and merging them back into translated files.

## 2. Core Functionality

### 2.1. File Handling

-   **Input:** The tool shall accept a path to a single file or a directory.
-   **File Discovery:** When given a directory, the tool shall be able to recursively find files to translate. A `--recurse` flag should control this behavior.
-   **Output:** The tool shall support two output modes:
    -   Saving translated files to a specified output directory, mirroring the source directory structure.
    -   Overwriting the original files with their translated content, using an `--overwrite` flag.

### 2.2. Translation Pipeline

The translation process shall follow these steps:

1.  **Locate:** Identify all files to be translated based on the input path and recursion settings.
2.  **Chunk:** Split the content of each file into smaller, manageable chunks suitable for the selected translation engine.
3.  **Translate:** Translate each chunk using the specified engine.
4.  **Merge:** Combine the translated chunks to reconstruct the full translated content of each file.
5.  **Save:** Write the translated content to the destination.

### 2.3. Content-Type Detection

-   The tool shall automatically detect if a file's content is HTML and handle it appropriately to preserve markup during translation.

## 3. Translation Engines

The tool shall support multiple translation engines.

### 3.1. Pre-integrated Engines

-   The tool shall integrate with the `translators` and `deep-translator` Python packages, allowing users to select any of their supported engines (e.g., `google`, `bing`, `deepl`).

### 3.2. Custom LLM-based Engines

#### 3.2.1. `hysf` Engine

-   **Provider:** Siliconflow
-   **Model:** `tencent/Hunyuan-MT-7B`
-   **Implementation:** Use the `openai` Python package to make API calls to the Siliconflow endpoint (`https://api.siliconflow.com/v1/chat/completions`).
-   **Authentication:** The API key shall be retrieved from the configuration.
-   **Resilience:** API calls shall be wrapped with `tenacity` for automatic retries.

#### 3.2.2. `ullm` (Universal Large Language Model) Engine

-   **Configurability:** This engine shall be highly configurable, allowing users to define profiles for different LLM providers. Each profile shall specify:
    -   API base URL
    -   Model name
    -   API key (or reference to it)
    -   Temperature
    -   Chunk size
    -   Maximum input token length
-   **Vocabulary Management:**
    -   The engine shall support a "prolog" in the first chunk, which can contain a JSON object of predefined vocabulary.
    -   The prompt shall instruct the LLM to return the translation within an `<output>` tag.
    -   The prompt shall also instruct the LLM to optionally return a `<vocabulary>` tag containing a JSON object of newly established term translations.
    -   The tool shall parse the `<vocabulary>` output, merge it with the existing vocabulary, and pass the updated vocabulary to subsequent chunks.
-   **Vocabulary Persistence:**
    -   A `--save-voc` flag shall enable saving the final, merged vocabulary as a JSON file next to the translated output file.

## 4. Configuration

-   **Storage:** Configuration shall be stored in a user-specific directory using the `platformdirs` package.
-   **Credentials:** The configuration shall securely store API keys. It must support storing either the raw API key value or the name of an environment variable that holds the key.
-   **Engine Settings:** The configuration shall allow specifying engine-specific settings, such as chunk sizes.

## 5. Command-Line Interface (CLI)

-   The tool shall provide a CLI based on `python-fire`.
-   The main command shall be `translate`.
-   **CLI Arguments:**
    -   `path`: The input file or directory.
    -   `--from-lang`: Source language (default: `auto`).
    -   `--to-lang`: Target language (default: `en`).
    -   `--engine`: The translation engine to use.
    -   `--recurse` / `--no-recurse`: Enable/disable recursive file discovery.
    -   `--overwrite`: Overwrite original files instead of saving to an output directory.
    -   `--output`: The directory to save translated files.
    -   `--save-voc`: Save the vocabulary file.

## 6. Python API

-   The package shall expose a Python API for programmatic use.

## 7. Dependencies

-   `translators`
-   `deep-translator`
-   `openai`
-   `tenacity`
-   `platformdirs`
-   `python-fire`
-   `semantic-text-splitter` (or similar for chunking)

</document_content>
</document>

<document index="18">
<source>TESTING.md</source>
<document_content>
---
this_file: TESTING.md
---
# Testing Guide

## Running Tests

### Unit Tests
Run the standard test suite:
```bash
python -m pytest
```

With coverage report:
```bash
python -m pytest --cov=. --cov-report=term-missing
```

### Integration Tests
Integration tests make real API calls and are skipped by default to avoid network dependencies in CI.

To run integration tests locally:
```bash
export ABERSETZ_INTEGRATION_TESTS=true
python -m pytest tests/test_integration.py -v
```

Some tests require API keys:
```bash
export SILICONFLOW_API_KEY=your-api-key
export ABERSETZ_INTEGRATION_TESTS=true
python -m pytest tests/test_integration.py -v
```

### Test Markers
- `@pytest.mark.integration` - Tests that require network access
- `@pytest.mark.skipif` - Conditional test execution based on environment

### Continuous Testing
Use pytest-watch for automatic test runs on file changes:
```bash
uvx pytest-watch -- -xvs
```

## Test Coverage
Current coverage: **91%**

Areas with good coverage:
- Configuration management (90%)
- Translation pipeline (97%)
- CLI interface (78%)
- Engine abstractions (82%)

## Testing Best Practices
1. Write tests before implementing features (TDD)
2. Test edge cases: empty inputs, None values, large inputs
3. Mock external services in unit tests
4. Use integration tests sparingly for real API validation
5. Keep tests focused and independent
6. Use descriptive test names: `test_function_when_condition_then_result`
</document_content>
</document>

<document index="19">
<source>TODO.md</source>
<document_content>
---
this_file: TODO.md
---
## Completed MVP Tasks
- [x] Scaffold config module with platformdirs persistence and tests.
- [x] Implement file discovery, HTML detection, and chunking helpers with coverage.
- [x] Integrate translation engines (translators, deep-translator, hysf, ullm) behind a common interface.
- [x] Assemble translation pipeline handling vocabulary propagation, outputs, and ``--save-voc``.
- [x] Wire Fire-based CLI entrypoint and console script exposing translate workflow.
- [x] Populate ``examples/`` with sample inputs, outputs, and walkthrough README snippet.
- [x] Refresh README, CLAUDE, and supporting docs to match new functionality.
- [x] Run full pytest + coverage, record results in WORK.md and finalize cleanup.

## Quality Improvements
- [x] Improve error handling for malformed config files and missing API keys
- [x] Add retry mechanism for translators/deep-translator engines
- [x] Create integration tests for real translation engines (with skip markers for CI)

## Small-Scale Quality Enhancements
- [x] Add input validation for language codes to prevent invalid language errors
- [x] Add progress indicator for multi-file translations using rich.progress
- [x] Add a `--version` flag to CLI that shows abersetz version
- [x] Reduce logging and rich output to minimum for cleaner interface

## Reliability & Robustness Improvements
- [ ] Add input file validation to check existence and readability before translation
- [ ] Add graceful handling of edge cases (empty files, very large files >10MB)
- [ ] Add offline smoke test to verify installation without network access

</document_content>
</document>

<document index="20">
<source>WORK.md</source>
<document_content>
---
this_file: WORK.md
---
# Work Log

## 2025-01-20
### MVP Complete
- Established planning artifacts (`PLAN.md`, `TODO.md`) and refreshed README/CLAUDE alignment.
- Implemented configuration store, chunking utilities, engine adapters, translation pipeline, and Fire CLI.
- Added example assets and comprehensive pytest suite covering config, chunking, engines, pipeline, and CLI wiring.
- Tests: `python -m pytest --cov=. --cov-report=term-missing` (14 tests pass, coverage 91%).
- Fixed pyproject.toml configuration for modern uv/hatch compatibility.
- Created CHANGELOG.md and DEPENDENCIES.md documentation.

### Quality Improvements (In Progress)
Working on 3 targeted improvements for robustness:

1. **Better Error Handling**
   - Add validation for malformed JSON config files
   - Improve error messages when API keys are missing
   - Add helpful suggestions for common configuration mistakes

2. **Network Retry Logic**
   - Add tenacity retry wrapper for translators engine
   - Add retry logic for deep-translator engines
   - Ensure consistent retry behavior across all engines

3. **Integration Testing**
   - Create integration tests for real translation APIs
   - Add pytest markers to skip in CI environments
   - Document how to run integration tests locally

</document_content>
</document>

<document index="21">
<source>build.sh</source>
<document_content>
#!/usr/bin/env bash
cd "$(dirname "$0")"
uvx hatch clean; 
fd -e py -x autoflake {}; 
fd -e py -x pyupgrade --py311-plus {}; 
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}; 
fd -e py -x ruff format --respect-gitignore --target-version py311 {};
uvx hatch fmt;
llms .;
gitnextver .; 
uvx hatch build;
uv publish;
</document_content>
</document>

<document index="22">
<source>docs/_config.yml</source>
<document_content>
# Jekyll configuration for abersetz documentation
# Using just-the-docs theme

title: abersetz
description: Minimalist file translator with pluggable engines
baseurl: "/abersetz"
url: "https://twardoch.github.io"

# Theme configuration
remote_theme: just-the-docs/just-the-docs@v0.7.0
color_scheme: light

# Enable search
search_enabled: true
search:
  heading_level: 2
  previews: 3
  preview_words_before: 5
  preview_words_after: 10
  tokenizer_separator: /[\s/]+/
  rel_url: true
  button: false

# Enable navigation
nav_enabled: true
nav_sort: case_sensitive

# Footer
footer_content: "Copyright &copy; 2025 Adam Twardoch. Distributed under the MIT License."
last_edit_timestamp: true
last_edit_time_format: "%b %e %Y at %I:%M %p"

# Back to top link
back_to_top: true
back_to_top_text: "Back to top"

# External links
aux_links:
  "GitHub":
    - "https://github.com/twardoch/abersetz"
  "PyPI":
    - "https://pypi.org/project/abersetz"

# Collections for organizing content
collections:
  docs:
    permalink: "/:collection/:path/"
    output: true

just_the_docs:
  collections:
    docs:
      name: Documentation
      nav_exclude: false
      search_exclude: false

# Plugins
plugins:
  - jekyll-seo-tag
  - jekyll-sitemap

# Markdown settings
markdown: kramdown
kramdown:
  syntax_highlighter_opts:
    block:
      line_numbers: false

# Exclude files
exclude:
  - "*.py"
  - "*.sh"
  - "requirements.txt"
  - "Gemfile"
  - "Gemfile.lock"
  - "node_modules/"
  - "vendor/"
</document_content>
</document>

<document index="23">
<source>docs/api.md</source>
<document_content>
---
layout: default
title: Python API
nav_order: 4
---

# Python API Reference
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Overview

The abersetz Python API provides programmatic access to all translation functionality.

## Main Functions

### translate_path

Main function for translating files or directories.

```python
from abersetz import translate_path, TranslatorOptions

results = translate_path(
    path="document.txt",
    options=TranslatorOptions(to_lang="es"),
    config=None,  # Optional custom config
    client=None   # Optional HTTP client
)
```

**Parameters:**
- `path` (str | Path): File or directory to translate
- `options` (TranslatorOptions): Translation settings
- `config` (AbersetzConfig, optional): Custom configuration
- `client` (optional): HTTP client for API calls

**Returns:**
- List[TranslationResult]: Results for each translated file

## Core Classes

### TranslatorOptions

Configuration for translation operations.

```python
from abersetz import TranslatorOptions

options = TranslatorOptions(
    engine="translators/google",
    from_lang="auto",
    to_lang="en",
    recurse=True,
    overwrite=False,
    output_dir=Path("output/"),
    save_vocabulary=False,
    chunk_size=1200,
    html_chunk_size=1800,
    include=("*.txt", "*.md"),
    exclude=("*test*",),
    dry_run=False,
    prolog={"role": "translator"},
    initial_vocabulary={"term": "translation"}
)
```

**Attributes:**
- `engine` (str): Translation engine name
- `from_lang` (str): Source language code
- `to_lang` (str): Target language code
- `recurse` (bool): Process subdirectories
- `overwrite` (bool): Replace original files
- `output_dir` (Path): Output directory path
- `save_vocabulary` (bool): Save vocabulary JSON
- `chunk_size` (int): Characters per text chunk
- `html_chunk_size` (int): Characters per HTML chunk
- `include` (tuple): File patterns to include
- `exclude` (tuple): File patterns to exclude
- `dry_run` (bool): Preview without translating
- `prolog` (dict): Initial context for LLMs
- `initial_vocabulary` (dict): Starting vocabulary

### TranslationResult

Result information for a translated file.

```python
from abersetz import TranslationResult

result = TranslationResult(
    source=Path("input.txt"),
    destination=Path("output.txt"),
    chunks=5,
    vocabulary={"term": "translation"},
    format=TextFormat.PLAIN
)
```

**Attributes:**
- `source` (Path): Source file path
- `destination` (Path): Output file path
- `chunks` (int): Number of chunks processed
- `vocabulary` (dict): Final vocabulary (LLM engines)
- `format` (TextFormat): Detected format (PLAIN, HTML, MARKDOWN)

### PipelineError

Exception raised when translation fails.

```python
from abersetz import PipelineError

try:
    results = translate_path("missing.txt")
except PipelineError as e:
    print(f"Translation failed: {e}")
```

## Configuration Management

### Loading Configuration

```python
from abersetz.config import load_config

config = load_config()
print(config.defaults.engine)
print(config.defaults.to_lang)
```

### Saving Configuration

```python
from abersetz.config import save_config, AbersetzConfig, Defaults

config = AbersetzConfig(
    defaults=Defaults(
        engine="translators/google",
        to_lang="es",
        chunk_size=1500
    )
)

save_config(config)
```

### Custom Engine Configuration

```python
from abersetz.config import EngineConfig, Credential

config.engines["custom"] = EngineConfig(
    name="custom",
    chunk_size=2000,
    credential=Credential(env="CUSTOM_API_KEY"),
    options={
        "base_url": "https://api.custom.com/v1",
        "model": "translation-v1"
    }
)
```

## Engine Management

### Creating Engines

```python
from abersetz.engines import create_engine
from abersetz.config import load_config

config = load_config()
engine = create_engine("translators/google", config)
```

### Using Engines Directly

```python
from abersetz.engines import EngineRequest

request = EngineRequest(
    text="Hello world",
    source_lang="en",
    target_lang="es",
    is_html=False,
    vocabulary={},
    prolog={},
    chunk_index=0,
    total_chunks=1
)

result = engine.translate(request)
print(result.text)  # "Hola mundo"
```

## Text Processing

### Format Detection

```python
from abersetz.chunking import detect_format, TextFormat

text = "<h1>Title</h1><p>Content</p>"
format = detect_format(text)
# Returns TextFormat.HTML
```

### Text Chunking

```python
from abersetz.chunking import chunk_text, TextFormat

chunks = chunk_text(
    text="Long document...",
    max_size=1000,
    format=TextFormat.MARKDOWN
)
```

## Complete Examples

### Simple Translation

```python
from abersetz import translate_path, TranslatorOptions

# Translate a single file
results = translate_path(
    "document.txt",
    TranslatorOptions(
        to_lang="fr",
        engine="translators/google"
    )
)

for result in results:
    print(f"Translated: {result.source} -> {result.destination}")
    print(f"Chunks: {result.chunks}")
```

### Batch Processing

```python
from pathlib import Path
from abersetz import translate_path, TranslatorOptions

def batch_translate(source_dir, languages, engine="translators/google"):
    """Translate to multiple languages."""
    results = {}

    for lang in languages:
        print(f"Translating to {lang}...")
        lang_results = translate_path(
            source_dir,
            TranslatorOptions(
                to_lang=lang,
                engine=engine,
                output_dir=Path(f"output_{lang}"),
                recurse=True
            )
        )
        results[lang] = lang_results

    return results

# Usage
results = batch_translate("docs/", ["es", "fr", "de"])
```

### Custom Workflow

```python
from abersetz import translate_path, TranslatorOptions
from abersetz.config import load_config, save_config
import json

class TranslationWorkflow:
    def __init__(self):
        self.config = load_config()
        self.vocabulary = {}

    def translate_with_vocabulary(self, files, to_lang):
        """Maintain vocabulary across files."""
        all_results = []

        for file in files:
            results = translate_path(
                file,
                TranslatorOptions(
                    to_lang=to_lang,
                    engine="ullm/default",
                    initial_vocabulary=self.vocabulary,
                    save_vocabulary=True
                ),
                config=self.config
            )

            if results:
                # Update vocabulary
                self.vocabulary.update(results[0].vocabulary)
                all_results.extend(results)

        # Save final vocabulary
        with open(f"vocabulary_{to_lang}.json", "w") as f:
            json.dump(self.vocabulary, f, indent=2)

        return all_results

# Usage
workflow = TranslationWorkflow()
results = workflow.translate_with_vocabulary(
    ["doc1.md", "doc2.md", "doc3.md"],
    "es"
)
```

### Error Handling

```python
from abersetz import translate_path, TranslatorOptions, PipelineError
import logging

def safe_translate(path, **options):
    """Translate with comprehensive error handling."""
    try:
        results = translate_path(
            path,
            TranslatorOptions(**options)
        )
        return results

    except PipelineError as e:
        logging.error(f"Translation pipeline error: {e}")
        return None

    except FileNotFoundError as e:
        logging.error(f"File not found: {e}")
        return None

    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        raise

# Usage with retry
import time

for attempt in range(3):
    results = safe_translate("document.txt", to_lang="es")
    if results:
        break
    time.sleep(2 ** attempt)  # Exponential backoff
```

### Async Translation

```python
import asyncio
from abersetz import translate_path, TranslatorOptions

async def translate_async(path, to_lang):
    """Async wrapper for translation."""
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(
        None,
        translate_path,
        path,
        TranslatorOptions(to_lang=to_lang)
    )

async def translate_multiple(files, to_lang):
    """Translate multiple files concurrently."""
    tasks = [translate_async(f, to_lang) for f in files]
    return await asyncio.gather(*tasks)

# Usage
files = ["doc1.txt", "doc2.txt", "doc3.txt"]
results = asyncio.run(translate_multiple(files, "es"))
```

## Advanced Topics

### Custom Engines

```python
from abersetz.engines import EngineBase, EngineRequest, EngineResult

class CustomEngine(EngineBase):
    """Custom translation engine implementation."""

    def __init__(self, config):
        super().__init__("custom", 1000, 1500)
        self.config = config

    def translate(self, request: EngineRequest) -> EngineResult:
        # Your translation logic here
        translated = self.call_api(request.text)
        return EngineResult(
            text=translated,
            vocabulary={}
        )
```

### Vocabulary Management

```python
from typing import Dict
import json

class VocabularyManager:
    """Manage translation vocabularies."""

    def __init__(self):
        self.vocabularies: Dict[str, Dict[str, str]] = {}

    def load(self, path: str, lang_pair: str):
        with open(path) as f:
            self.vocabularies[lang_pair] = json.load(f)

    def merge(self, *lang_pairs: str) -> Dict[str, str]:
        merged = {}
        for pair in lang_pairs:
            if pair in self.vocabularies:
                merged.update(self.vocabularies[pair])
        return merged

    def save(self, vocabulary: Dict[str, str], path: str):
        with open(path, "w") as f:
            json.dump(vocabulary, f, indent=2, ensure_ascii=False)
```

## See Also

- [CLI Reference](cli/)
- [Configuration Guide](configuration/)
- [Examples](examples/)
</document_content>
</document>

<document index="24">
<source>docs/cli.md</source>
<document_content>
---
layout: default
title: CLI Reference
nav_order: 3
---

# CLI Reference
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Overview

Abersetz provides two command-line tools:

- `abersetz`: Main CLI with subcommands
- `abtr`: Direct translation shorthand

## Main Commands

### abersetz tr

Translate files or directories.

```bash
abersetz tr PATH [OPTIONS]
```

#### Arguments

- `PATH`: File or directory to translate (required)

#### Options

| Option | Description | Default |
|--------|-------------|---------|
| `--to-lang` | Target language code | `en` |
| `--from-lang` | Source language code | `auto` |
| `--engine` | Translation engine | `translators/google` |
| `--output` | Output directory | `<lang>/<filename>` |
| `--recurse/--no-recurse` | Process subdirectories | `True` |
| `--overwrite` | Replace original files | `False` |
| `--include` | File patterns to include | `*.txt,*.md,*.html` |
| `--exclude` | File patterns to exclude | None |
| `--chunk-size` | Characters per chunk | `1200` |
| `--html-chunk-size` | Characters per HTML chunk | `1800` |
| `--save-voc` | Save vocabulary JSON | `False` |
| `--dry-run` | Preview without translating | `False` |
| `--verbose` | Enable debug output | `False` |

### abersetz config

Manage configuration settings.

```bash
abersetz config COMMAND
```

#### Subcommands

- `show`: Display current configuration
- `path`: Show configuration file location

### abersetz version

Display version information.

```bash
abersetz version
```

## Shorthand Command

### abtr

Direct translation command equivalent to `abersetz tr`:

```bash
abtr PATH [OPTIONS]
```

All options from `abersetz tr` are available.

## Usage Examples

### Basic Translation

Translate a single file:

```bash
abersetz tr document.txt --to-lang es
```

Translate to French using shorthand:

```bash
abtr document.txt --to-lang fr
```

### Directory Translation

Translate all files in a directory:

```bash
abersetz tr ./docs --to-lang de --output ./docs_de
```

With specific patterns:

```bash
abtr ./project \
  --include "*.md,*.txt" \
  --exclude "*test*,.*" \
  --to-lang ja
```

### Engine Selection

Use different translation engines:

```bash
# Google Translate (free)
abtr file.txt --to-lang pt --engine translators/google

# Bing Translate (free)
abtr file.txt --to-lang pt --engine translators/bing

# DeepL
abtr file.txt --to-lang pt --engine deep-translator/deepl

# SiliconFlow LLM
abtr file.txt --to-lang pt --engine hysf

# Custom LLM profile
abtr file.txt --to-lang pt --engine ullm/gpt4
```

### Advanced Options

Overwrite original files:

```bash
abersetz tr backup.txt --to-lang es --overwrite
```

Save vocabulary for LLM engines:

```bash
abtr technical.md \
  --to-lang de \
  --engine ullm/default \
  --save-voc
```

Dry run to preview:

```bash
abersetz tr large_project/ \
  --to-lang fr \
  --dry-run
```

Custom chunk sizes:

```bash
abtr document.html \
  --to-lang zh-CN \
  --html-chunk-size 3000
```

## Language Codes

Common language codes supported:

| Code | Language |
|------|----------|
| `en` | English |
| `es` | Spanish |
| `fr` | French |
| `de` | German |
| `it` | Italian |
| `pt` | Portuguese |
| `ru` | Russian |
| `ja` | Japanese |
| `ko` | Korean |
| `zh-CN` | Chinese (Simplified) |
| `zh-TW` | Chinese (Traditional) |
| `ar` | Arabic |
| `hi` | Hindi |
| `auto` | Auto-detect (source only) |

## Pattern Matching

Include/exclude patterns support wildcards:

- `*.txt` - All .txt files
- `doc*` - Files starting with "doc"
- `*test*` - Files containing "test"
- `.*` - Hidden files
- `*.{md,txt}` - Multiple extensions

## Environment Variables

Set default behaviors with environment variables:

```bash
# Default target language
export ABERSETZ_TO_LANG=es

# Default engine
export ABERSETZ_ENGINE=translators/bing

# API keys for LLM engines
export OPENAI_API_KEY=sk-...
export SILICONFLOW_API_KEY=sk-...
```

## Output Format

Translation results are printed as file paths:

```
/path/to/output/file1.txt
/path/to/output/file2.txt
```

Use `--verbose` for detailed progress:

```bash
abersetz tr docs/ --to-lang fr --verbose
```

## Error Handling

Common errors and solutions:

### Missing API key

```
Error: Missing API key for engine
```

Solution: Export the required environment variable:

```bash
export SILICONFLOW_API_KEY="your-key"
```

### No files matched

```
Error: No files matched under /path
```

Solution: Check your include patterns:

```bash
abtr . --include "*.md,*.txt"
```

### Network error

```
Error: Network error - Connection timeout
```

Solution: The tool automatically retries. Check your internet connection.

## Tips and Tricks

### Batch translation

Create a script for multiple languages:

```bash
for lang in es fr de ja; do
  abersetz tr docs/ --to-lang $lang --output docs_$lang
done
```

### Parallel processing

Use GNU parallel for speed:

```bash
find . -name "*.txt" | parallel -j4 abtr {} --to-lang es
```

### Progress tracking

For large projects, use verbose mode:

```bash
abersetz tr large_project/ --to-lang fr --verbose 2>&1 | tee translation.log
```

### Testing configuration

Always test with dry-run first:

```bash
abersetz tr important_docs/ --to-lang de --dry-run
```

## See Also

- [Configuration Guide](configuration/)
- [Python API Reference](api/)
- [Translation Engines](engines/)
</document_content>
</document>

<document index="25">
<source>docs/configuration.md</source>
<document_content>
---
layout: default
title: Configuration
nav_order: 5
---

# Configuration
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Overview

Abersetz stores configuration in a TOML file managed by `platformdirs`, ensuring cross-platform compatibility.

## Configuration Location

Find your configuration file:

```bash
abersetz config path
```

Typical locations:
- **Linux**: `~/.config/abersetz/config.toml`
- **macOS**: `~/Library/Application Support/abersetz/config.toml`
- **Windows**: `%APPDATA%\abersetz\config.toml`

## Configuration Structure

### Complete Example

```toml
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.openai]
env = "OPENAI_API_KEY"

[credentials.anthropic]
env = "ANTHROPIC_API_KEY"

[credentials.siliconflow]
env = "SILICONFLOW_API_KEY"

[credentials.deepseek]
env = "DEEPSEEK_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
credential = { name = "siliconflow" }
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.default.prolog]
```

## Configuration Sections

### defaults

Global default settings for all translations:

```toml
[defaults]
engine = "translators/google" # Default translation engine
from_lang = "auto"             # Source language (auto-detect)
to_lang = "en"                  # Target language
chunk_size = 1200              # Characters per text chunk
html_chunk_size = 1800         # Characters per HTML chunk
```


### credentials

API key storage with environment variable references:

```toml
[credentials.openai]
env = "OPENAI_API_KEY"        # Read from environment

[credentials.custom]
value = "sk-actual-key-here"  # Direct value (not recommended)
```


### engines

Custom engine configurations:

```toml
[engines.engine_name]
chunk_size = 2000

[engines.engine_name.credential]
name = "credential_name"

# Engine-specific options
[engines.engine_name.options]
```


## Setting Up Credentials

### Environment Variables (Recommended)

Store API keys as environment variables:

```bash
# Add to ~/.bashrc or ~/.zshrc
export OPENAI_API_KEY="sk-..."
export ANTHROPIC_API_KEY="sk-ant-..."
export SILICONFLOW_API_KEY="sk-..."
```

Then reference in config:

```toml
[credentials.openai]
env = "OPENAI_API_KEY"
```


### Direct Values (Not Recommended)

Store directly in config (less secure):

```toml
[credentials.openai]
value = "sk-actual-key-here"
```


## Engine Configuration

### LLM Engine (ullm)

Configure multiple LLM profiles:

```toml
[engines.ullm]
chunk_size = 2400

[engines.ullm.options.profiles.gpt4]
base_url = "https://api.openai.com/v1"
model = "gpt-4-turbo-preview"
credential = { name = "openai" }
temperature = 0.3
max_input_tokens = 128000

[engines.ullm.options.profiles.gpt4.prolog]
role = "You are an expert translator"

[engines.ullm.options.profiles.claude]
base_url = "https://api.anthropic.com/v1"
model = "claude-3-opus-20240229"
credential = { name = "anthropic" }
temperature = 0.3
max_input_tokens = 200000
```


Usage:
```bash
abtr file.txt --engine ullm/gpt4 --to-lang es
abtr file.txt --engine ullm/claude --to-lang fr
```

### Custom Endpoints

Configure self-hosted models:

```toml
[engines.local_llm]
chunk_size = 1500

[engines.local_llm.options]
base_url = "http://localhost:8080/v1"
model = "local-model"
temperature = 0.5
```


## Managing Configuration

### View Current Config

```bash
abersetz config show
```

Or pretty-print:

```bash
abersetz config show | jq '.'
```

### Edit Configuration

Edit directly:

```bash
# Find location
CONFIG_PATH=$(abersetz config path | tail -1)

# Edit with your preferred editor
nano "$CONFIG_PATH"
# or
vim "$CONFIG_PATH"
```

### Reset Configuration

Remove to reset to defaults:

```bash
rm "$(abersetz config path | tail -1)"
```

### Backup Configuration

```bash
CONFIG_PATH=$(abersetz config path | tail -1)
cp "$CONFIG_PATH" "$CONFIG_PATH.backup"
```

## Python Configuration API

### Load Configuration

```python
from abersetz.config import load_config

config = load_config()
print(config.defaults.engine)
print(config.defaults.to_lang)
```

### Modify Configuration

```python
from abersetz.config import load_config, save_config

config = load_config()

# Change defaults
config.defaults.to_lang = "es"
config.defaults.chunk_size = 1500

# Add credential
from abersetz.config import Credential
config.credentials["myapi"] = Credential(env="MY_API_KEY")

# Save changes
save_config(config)
```

### Add Custom Engine

```python
from abersetz.config import load_config, save_config, EngineConfig, Credential

config = load_config()

config.engines["custom"] = EngineConfig(
    name="custom",
    chunk_size=2000,
    credential=Credential(env="CUSTOM_API_KEY"),
    options={
        "base_url": "https://api.custom.com/v1",
        "model": "translation-v1",
        "temperature": 0.3
    }
)

save_config(config)
```

## Environment Variables

### Abersetz-specific

Override defaults with environment variables:

```bash
export ABERSETZ_ENGINE="translators/bing"
export ABERSETZ_TO_LANG="es"
export ABERSETZ_CHUNK_SIZE="1500"
```

### API Keys

Standard API key variables:

```bash
# OpenAI
export OPENAI_API_KEY="sk-..."

# Anthropic
export ANTHROPIC_API_KEY="sk-ant-..."

# Google
export GOOGLE_API_KEY="..."

# SiliconFlow
export SILICONFLOW_API_KEY="sk-..."

# DeepSeek
export DEEPSEEK_API_KEY="..."

# Mistral
export MISTRAL_API_KEY="..."

# Together AI
export TOGETHERAI_API_KEY="..."
```

## Configuration Templates

### Minimal Config

```toml
[defaults]
engine = "translators/google"
to_lang = "es"
```


### Multi-engine Config

```toml
[defaults]
engine = "translators/google"

[credentials.openai]
env = "OPENAI_API_KEY"

[credentials.anthropic]
env = "ANTHROPIC_API_KEY"

[engines.gpt]
chunk_size = 3000

[engines.gpt.credential]
name = "openai"

[engines.gpt.options]
model = "gpt-4-turbo-preview"
base_url = "https://api.openai.com/v1"

[engines.claude]
chunk_size = 3000

[engines.claude.credential]
name = "anthropic"

[engines.claude.options]
model = "claude-3-opus-20240229"
base_url = "https://api.anthropic.com/v1"
```


### Enterprise Config

```toml
[defaults]
engine = "corporate_llm"
to_lang = "en"
chunk_size = 2000

[credentials.corporate]
env = "CORP_TRANSLATION_KEY"

[engines.corporate_llm]
chunk_size = 2500

[engines.corporate_llm.credential]
name = "corporate"

[engines.corporate_llm.options]
base_url = "https://translation.company.com/v1"
model = "corp-translator-v2"
temperature = 0.2
max_retries = 5
timeout = 30
```


## Security Best Practices

1. **Never commit API keys**: Add `config.toml` to `.gitignore`

2. **Use environment variables**: Store keys in environment, not config

3. **Rotate keys regularly**: Update API keys periodically

4. **Restrict file permissions**:
   ```bash
   chmod 600 "$(abersetz config path | tail -1)"
   ```

5. **Use separate keys**: Different keys for dev/prod environments

## Troubleshooting

### Config not loading

Check file exists and is valid JSON:

```bash
CONFIG_PATH=$(abersetz config path | tail -1)
cat "$CONFIG_PATH" | jq '.'
```

### API key not found

Verify environment variable is set:

```bash
echo $OPENAI_API_KEY
```

### Permission denied

Fix file permissions:

```bash
chmod 644 "$(abersetz config path | tail -1)"
```

## See Also

- [Translation Engines](engines/)
- [Python API](api/)
- [Examples](examples/)
</document_content>
</document>

<document index="26">
<source>docs/index.md</source>
<document_content>
---
layout: home
title: Home
nav_order: 1
description: "Abersetz is a minimalist file translator that reuses proven machine translation engines"
permalink: /
---

# abersetz
{: .fs-9 }

Minimalist file translator with pluggable engines
{: .fs-6 .fw-300 }

[Get started](#getting-started){: .btn .btn-primary .fs-5 .mb-4 .mb-md-0 .mr-2 }
[View on GitHub](https://github.com/twardoch/abersetz){: .btn .fs-5 .mb-4 .mb-md-0 }

---

## Why abersetz?

- **File-focused**: Designed for translating documents, not single strings
- **Multiple engines**: Supports free and paid translation services
- **Vocabulary consistency**: LLM engines maintain terminology across chunks
- **Simple CLI**: Clean interface with minimal output
- **Python API**: Full programmatic access for automation

## Features

- ğŸ”„ **Multiple translation engines**
  - Free: Google, Bing via `translators` and `deep-translator`
  - LLM: OpenAI, Anthropic, SiliconFlow, and 20+ providers
  - Custom endpoints for self-hosted models

- ğŸ“ **Smart file handling**
  - Recursive directory translation
  - Pattern matching with include/exclude
  - HTML markup preservation
  - Automatic format detection

- ğŸ§© **Intelligent chunking**
  - Semantic text splitting
  - Configurable chunk sizes per engine
  - Context preservation across chunks

- ğŸ“š **Vocabulary management**
  - JSON vocabulary propagation
  - Consistent terminology in long documents
  - Optional vocabulary export

## Getting Started

### Installation

```bash
pip install abersetz
```

### Quick Start

Translate a single file:
```bash
abersetz tr document.txt --to-lang es
```

Or use the shorthand:
```bash
abtr document.txt --to-lang es
```

Translate a directory:
```bash
abersetz tr ./docs --to-lang fr --output ./docs_fr
```

### Configuration

Abersetz stores configuration in your user directory:

```bash
abersetz config path  # Show config location
abersetz config show  # Display current settings
```

## Example Usage

### CLI Examples

```bash
# Translate with specific engine
abtr file.txt --to-lang de --engine translators/google

# Translate markdown files only
abtr . --include "*.md" --to-lang ja --output ./ja

# Dry run to preview
abersetz tr project/ --to-lang zh-CN --dry-run

# Use LLM with vocabulary
export SILICONFLOW_API_KEY="your-key"
abtr technical.md --to-lang es --engine hysf --save-voc
```

### Python API

```python
from abersetz import translate_path, TranslatorOptions

# Simple translation
results = translate_path(
    "document.txt",
    TranslatorOptions(
        to_lang="fr",
        engine="translators/google"
    )
)

# Batch with patterns
results = translate_path(
    "docs/",
    TranslatorOptions(
        to_lang="de",
        include=("*.md", "*.txt"),
        output_dir="docs_de/"
    )
)
```

## Documentation

- [Installation Guide](installation/)
- [CLI Reference](cli/)
- [Python API](api/)
- [Configuration](configuration/)
- [Translation Engines](engines/)
- [Examples](examples/)

## License

MIT License - see [LICENSE](https://github.com/twardoch/abersetz/blob/main/LICENSE) for details.
</document_content>
</document>

<document index="27">
<source>docs/installation.md</source>
<document_content>
---
layout: default
title: Installation
nav_order: 2
---

# Installation
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Requirements

- Python 3.10 or higher
- pip or uv package manager

## Installing with pip

The simplest way to install abersetz:

```bash
pip install abersetz
```

## Installing with uv

If you use the modern uv package manager:

```bash
uv pip install abersetz
```

## Installing from source

To install the latest development version:

```bash
git clone https://github.com/twardoch/abersetz.git
cd abersetz
pip install -e .
```

## Verifying installation

After installation, verify abersetz is working:

```bash
# Check version
abersetz version

# Show help
abersetz --help

# Test with dry run
echo "Hello world" > test.txt
abersetz tr test.txt --to-lang es --dry-run
```

## Dependencies

Abersetz automatically installs these dependencies:

### Core dependencies
- **translators** (>=5.9): Multiple free translation APIs
- **deep-translator** (>=1.11): Alternative translation providers
- **openai** (>=1.51): LLM-based translation engines
- **tenacity** (>=8.4): Retry logic for API calls

### Utility dependencies
- **fire** (>=0.5): CLI interface generation
- **rich** (>=13.9): Terminal formatting
- **loguru** (>=0.7): Structured logging
- **platformdirs** (>=4.3): Cross-platform config paths
- **semantic-text-splitter** (>=0.7): Intelligent text chunking

## Optional: Setting up API keys

For LLM-based translation engines, you'll need API keys:

```bash
# OpenAI GPT models
export OPENAI_API_KEY="sk-..."

# Anthropic Claude models
export ANTHROPIC_API_KEY="sk-ant-..."

# SiliconFlow (Hunyuan translator)
export SILICONFLOW_API_KEY="sk-..."

# Google Gemini
export GOOGLE_API_KEY="..."

# Add to your shell profile to persist
echo 'export OPENAI_API_KEY="sk-..."' >> ~/.bashrc
```

## Shell completion (optional)

Enable tab completion for bash:

```bash
# Generate completion script
python -c "import fire; fire.Fire()" -- --completion > ~/.abersetz-completion.bash

# Add to bashrc
echo "source ~/.abersetz-completion.bash" >> ~/.bashrc

# Reload shell
source ~/.bashrc
```

## Docker installation (alternative)

Run abersetz in a container:

```dockerfile
FROM python:3.12-slim

RUN pip install abersetz

WORKDIR /data

ENTRYPOINT ["abersetz"]
```

Build and use:

```bash
docker build -t abersetz .
docker run -v $(pwd):/data abersetz tr /data/file.txt --to-lang es
```

## Troubleshooting

### Command not found

If `abersetz` command is not found after installation:

1. Check pip installed it to PATH:
   ```bash
   pip show -f abersetz | grep Location
   ```

2. Ensure scripts directory is in PATH:
   ```bash
   export PATH="$HOME/.local/bin:$PATH"
   ```

### Permission denied

On Linux/Mac, you may need to add execute permissions:

```bash
chmod +x ~/.local/bin/abersetz
chmod +x ~/.local/bin/abtr
```

### SSL certificate errors

If you encounter SSL errors with API calls:

```bash
# Update certificates
pip install --upgrade certifi

# Or disable SSL verification (not recommended)
export CURL_CA_BUNDLE=""
```

## Next steps

- [Configure abersetz](configuration/)
- [Learn CLI commands](cli/)
- [Explore examples](examples/)
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/examples/advanced_api.py
# Language: python

import asyncio
import json
from pathlib import Path
from abersetz import TranslationResult, TranslatorOptions, translate_path
from abersetz.config import AbersetzConfig, load_config
from abersetz.engines import EngineRequest, create_engine
import sys

class TranslationWorkflow:
    """Advanced translation workflow with progress tracking."""
    def __init__((self, config: AbersetzConfig = None)):
    def translate_project((
        self, source_dir: str, target_langs: list[str], engine: str = "translators/google"
    )):
        """Translate entire project to multiple languages."""
    def generate_report((self, output_file: str = "translation_report.json")):
        """Generate detailed translation report."""

class VocabularyManager:
    """Manage translation vocabularies across projects."""
    def __init__((self)):
    def load_vocabulary((self, file_path: str, lang_pair: str)):
        """Load vocabulary from JSON file."""
    def merge_vocabularies((self, *lang_pairs: str)) -> dict[str, str]:
        """Merge multiple vocabularies."""
    def translate_with_consistency((
        self, files: list[str], to_lang: str, base_vocabulary: dict[str, str] = None
    )):
        """Translate files with consistent terminology."""

class ParallelTranslator:
    """Translate using multiple engines in parallel for comparison."""
    def translate_with_engine((self, text: str, engine_name: str, to_lang: str)):
        """Async translation with a specific engine."""
    def compare_translations((self, text: str, engines: list[str], to_lang: str)):
        """Compare translations from multiple engines."""

class IncrementalTranslator:
    def __init__((self, checkpoint_file: str = ".translation_checkpoint.json")):
    def load_checkpoint((self)) -> set:
    def save_checkpoint((self)):
    def translate_incrementally((self, source_dir: str, to_lang: str)):

def __init__((self, config: AbersetzConfig = None)):

def translate_project((
        self, source_dir: str, target_langs: list[str], engine: str = "translators/google"
    )):
    """Translate entire project to multiple languages."""

def generate_report((self, output_file: str = "translation_report.json")):
    """Generate detailed translation report."""

def __init__((self)):

def load_vocabulary((self, file_path: str, lang_pair: str)):
    """Load vocabulary from JSON file."""

def merge_vocabularies((self, *lang_pairs: str)) -> dict[str, str]:
    """Merge multiple vocabularies."""

def translate_with_consistency((
        self, files: list[str], to_lang: str, base_vocabulary: dict[str, str] = None
    )):
    """Translate files with consistent terminology."""

def translate_with_engine((self, text: str, engine_name: str, to_lang: str)):
    """Async translation with a specific engine."""

def compare_translations((self, text: str, engines: list[str], to_lang: str)):
    """Compare translations from multiple engines."""

def example_multi_language(()):
    """Translate documentation to multiple languages."""

def example_vocabulary_consistency(()):
    """Maintain consistent terminology across documents."""

def example_parallel_comparison(()):
    """Compare translations from different engines."""

def example_incremental_translation(()):
    """Translate large projects incrementally."""

def __init__((self, checkpoint_file: str = ".translation_checkpoint.json")):

def load_checkpoint((self)) -> set:

def save_checkpoint((self)):

def translate_incrementally((self, source_dir: str, to_lang: str)):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/examples/basic_api.py
# Language: python

from pathlib import Path
from abersetz import TranslatorOptions, translate_path
from abersetz.config import load_config, save_config
from abersetz.config import Credential, EngineConfig
import sys

def example_simple(()):
    """Translate a single file with default settings."""

def example_batch(()):
    """Translate multiple files to a specific directory."""

def example_llm_with_vocabulary(()):
    """Use LLM translation with custom vocabulary."""

def example_dry_run(()):
    """Test translation without actually calling APIs."""

def example_html(()):
    """Translate HTML files while preserving markup."""

def example_with_config(()):
    """Use custom configuration for translation."""


<document index="28">
<source>examples/batch_translate.sh</source>
<document_content>
#!/bin/bash
# this_file: examples/batch_translate.sh

# Advanced batch translation scripts

set -e  # Exit on error

# Configuration
PROJECT_ROOT="${1:-./docs}"
OUTPUT_BASE="${2:-./translations}"
LANGUAGES=("es" "fr" "de" "ja" "zh-CN" "pt" "it" "ru")
ENGINE="${ABERSETZ_ENGINE:-translators/google}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Abersetz Batch Translation ===${NC}"
echo "Source: $PROJECT_ROOT"
echo "Output: $OUTPUT_BASE"
echo "Engine: $ENGINE"
echo ""

# Function to translate to a single language
translate_lang() {
    local lang=$1
    local output_dir="$OUTPUT_BASE/$lang"

    echo -e "${BLUE}Translating to $lang...${NC}"

    if abersetz tr "$PROJECT_ROOT" \
        --to-lang "$lang" \
        --engine "$ENGINE" \
        --output "$output_dir" \
        --recurse \
        --include "*.md,*.txt,*.html" \
        --exclude ".*,*test*,*draft*"; then
        echo -e "${GREEN}âœ“ $lang completed${NC}"
        return 0
    else
        echo -e "${RED}âœ— $lang failed${NC}"
        return 1
    fi
}

# Create output directory
mkdir -p "$OUTPUT_BASE"

# Track results
SUCCESS_COUNT=0
FAILED_LANGS=()

# Translate to each language
for lang in "${LANGUAGES[@]}"; do
    if translate_lang "$lang"; then
        ((SUCCESS_COUNT++))
    else
        FAILED_LANGS+=("$lang")
    fi
    echo ""
done

# Summary
echo -e "${BLUE}=== Translation Summary ===${NC}"
echo "Successfully translated to $SUCCESS_COUNT/${#LANGUAGES[@]} languages"

if [ ${#FAILED_LANGS[@]} -gt 0 ]; then
    echo -e "${RED}Failed languages: ${FAILED_LANGS[*]}${NC}"
    exit 1
else
    echo -e "${GREEN}All translations completed successfully!${NC}"
fi

# Generate index file
INDEX_FILE="$OUTPUT_BASE/index.md"
echo "# Translations" > "$INDEX_FILE"
echo "" >> "$INDEX_FILE"
echo "Available translations of $PROJECT_ROOT:" >> "$INDEX_FILE"
echo "" >> "$INDEX_FILE"

for lang in "${LANGUAGES[@]}"; do
    if [ -d "$OUTPUT_BASE/$lang" ]; then
        file_count=$(find "$OUTPUT_BASE/$lang" -type f | wc -l)
        echo "- [$lang]($lang/) - $file_count files" >> "$INDEX_FILE"
    fi
done

echo -e "${GREEN}Index generated at $INDEX_FILE${NC}"
</document_content>
</document>

<document index="29">
<source>examples/config_setup.sh</source>
<document_content>
#!/bin/bash
# this_file: examples/config_setup.sh

# Setup and configure abersetz with various engines

set -e

echo "=== Abersetz Configuration Setup ==="
echo ""

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to setup environment variable
setup_env_var() {
    local var_name=$1
    local var_description=$2

    if [ -z "${!var_name:-}" ]; then
        echo "âš  $var_name not set"
        echo "  Description: $var_description"
        echo "  To set: export $var_name='your_api_key_here'"
        return 1
    else
        echo "âœ“ $var_name is configured"
        return 0
    fi
}

# Check abersetz installation
echo "Checking installation..."
if command_exists abersetz; then
    echo "âœ“ abersetz is installed"
    abersetz version
else
    echo "âœ— abersetz not found. Install with: pip install abersetz"
    exit 1
fi

echo ""

# Show config location
echo "Configuration location:"
abersetz config path
echo ""

# Check API keys for various engines
echo "Checking API keys for LLM engines:"
echo ""

setup_env_var "OPENAI_API_KEY" "OpenAI API for GPT models"
setup_env_var "ANTHROPIC_API_KEY" "Anthropic API for Claude models"
setup_env_var "SILICONFLOW_API_KEY" "SiliconFlow API for Hunyuan translation"
setup_env_var "DEEPSEEK_API_KEY" "DeepSeek API for Chinese models"
setup_env_var "GROQ_API_KEY" "Groq API for fast inference"
setup_env_var "GOOGLE_API_KEY" "Google API for Gemini models"

echo ""

# Test available engines
echo "Testing available engines:"
echo ""

# Test free engines (no API key required)
echo "1. Testing free engines..."
for engine in "translators/google" "translators/bing" "deep-translator/google"; do
    echo -n "  $engine: "
    if echo "Hello" | abtr - --to-lang es --engine "$engine" --dry-run >/dev/null 2>&1; then
        echo "âœ“"
    else
        echo "âœ—"
    fi
done

echo ""

# Create sample configuration
CONFIG_FILE="$HOME/.config/abersetz/config.toml"
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Creating default configuration..."
    mkdir -p "$(dirname "$CONFIG_FILE")"
    cat > "$CONFIG_FILE" <<'EOF'
[defaults]
engine = "translators/google"
from_lang = "auto"
to_lang = "en"
chunk_size = 1200
html_chunk_size = 1800

[credentials.openai]
env = "OPENAI_API_KEY"

[credentials.anthropic]
env = "ANTHROPIC_API_KEY"

[credentials.siliconflow]
env = "SILICONFLOW_API_KEY"

[credentials.deepseek]
env = "DEEPSEEK_API_KEY"

[credentials.groq]
env = "GROQ_API_KEY"

[credentials.google]
env = "GOOGLE_API_KEY"

[engines.hysf]
chunk_size = 2400

[engines.hysf.credential]
name = "siliconflow"

[engines.hysf.options]
model = "tencent/Hunyuan-MT-7B"
base_url = "https://api.siliconflow.com/v1"
temperature = 0.3

[engines.ullm]
chunk_size = 2400

[engines.ullm.options.profiles.default]
base_url = "https://api.siliconflow.com/v1"
model = "tencent/Hunyuan-MT-7B"
credential = { name = "siliconflow" }
temperature = 0.3
max_input_tokens = 32000

[engines.ullm.options.profiles.gpt4]
base_url = "https://api.openai.com/v1"
model = "gpt-4-turbo-preview"
credential = { name = "openai" }
temperature = 0.3
max_input_tokens = 128000

[engines.ullm.options.profiles.claude]
base_url = "https://api.anthropic.com/v1"
model = "claude-3-opus-20240229"
credential = { name = "anthropic" }
temperature = 0.3
max_input_tokens = 200000

[engines.ullm.options.profiles.deepseek]
base_url = "https://api.deepseek.com/v1"
model = "deepseek-chat"
credential = { name = "deepseek" }
temperature = 0.3
max_input_tokens = 32000
EOF
    echo "âœ“ Configuration created at $CONFIG_FILE"
else
    echo "Configuration already exists at $CONFIG_FILE"
fi

echo ""

# Show current configuration
echo "Current configuration:"
abersetz config show | head -20
echo "..."

echo ""
echo "=== Setup Complete ==="
echo ""
echo "Quick test commands:"
echo "  abersetz tr test.txt --to-lang es                    # Use default engine"
echo "  abtr test.txt --to-lang fr --engine translators/bing # Use Bing"
echo "  abtr test.txt --to-lang de --engine hysf             # Use SiliconFlow LLM"
echo "  abtr test.txt --to-lang ja --engine ullm/gpt4        # Use GPT-4"
</document_content>
</document>

<document index="30">
<source>examples/engines_config.json</source>
<document_content>
{
  "defaults": {
    "engine": "translators/google",
    "from_lang": "auto",
    "to_lang": "en",
... (file content truncated to first 5 lines)
</document_content>
</document>

<document index="31">
<source>examples/pipeline.sh</source>
<document_content>
#!/bin/bash
# this_file: examples/pipeline.sh

# Complete translation pipeline with preprocessing and postprocessing

set -euo pipefail

# Configuration
SOURCE_DIR="${1:-.}"
TARGET_LANG="${2:-es}"
WORK_DIR="/tmp/abersetz_work_$$"
FINAL_OUTPUT="${3:-./translated_$TARGET_LANG}"

# Setup work directory
mkdir -p "$WORK_DIR"
trap "rm -rf $WORK_DIR" EXIT

echo "=== Abersetz Translation Pipeline ==="
echo "Source: $SOURCE_DIR"
echo "Target language: $TARGET_LANG"
echo "Output: $FINAL_OUTPUT"
echo ""

# Step 1: Find and copy translatable files
echo "Step 1: Collecting files..."
find "$SOURCE_DIR" -type f \( \
    -name "*.md" -o \
    -name "*.txt" -o \
    -name "*.html" -o \
    -name "*.htm" \
\) -not -path "*/\.*" -not -path "*/node_modules/*" \
   -not -path "*/venv/*" -not -path "*/__pycache__/*" | while read -r file; do
    rel_path="${file#$SOURCE_DIR/}"
    dest="$WORK_DIR/source/$rel_path"
    mkdir -p "$(dirname "$dest")"
    cp "$file" "$dest"
done

FILE_COUNT=$(find "$WORK_DIR/source" -type f 2>/dev/null | wc -l || echo 0)
echo "  Found $FILE_COUNT files"

if [ "$FILE_COUNT" -eq 0 ]; then
    echo "No files to translate!"
    exit 1
fi

# Step 2: Preprocess files (optional)
echo -e "\nStep 2: Preprocessing..."
# Example: Convert markdown links to absolute URLs
# find "$WORK_DIR/source" -name "*.md" -exec sed -i.bak 's|\](./|\](https://example.com/|g' {} \;
echo "  Preprocessing complete"

# Step 3: Translate
echo -e "\nStep 3: Translating..."
if abersetz tr "$WORK_DIR/source" \
    --to-lang "$TARGET_LANG" \
    --output "$WORK_DIR/translated" \
    --recurse; then
    echo "  Translation complete"
else
    echo "  Translation failed!"
    exit 1
fi

# Step 4: Postprocess translations
echo -e "\nStep 4: Postprocessing..."
# Example: Fix common translation issues
find "$WORK_DIR/translated" -type f -name "*.md" | while read -r file; do
    # Fix code blocks that might have been translated
    sed -i.bak 's/```[a-z]*$/```/g' "$file"
    # Remove backup files
    rm -f "${file}.bak"
done
echo "  Postprocessing complete"

# Step 5: Generate translation report
echo -e "\nStep 5: Generating report..."
REPORT_FILE="$WORK_DIR/translated/TRANSLATION_REPORT.md"
cat > "$REPORT_FILE" <<EOF
# Translation Report

## Summary
- **Source Directory**: $SOURCE_DIR
- **Target Language**: $TARGET_LANG
- **Date**: $(date)
- **Files Translated**: $FILE_COUNT

## File List
EOF

find "$WORK_DIR/translated" -type f -not -name "TRANSLATION_REPORT.md" | while read -r file; do
    rel_path="${file#$WORK_DIR/translated/}"
    size=$(wc -c < "$file")
    echo "- $rel_path ($(numfmt --to=iec-i --suffix=B $size))" >> "$REPORT_FILE"
done

echo "  Report generated"

# Step 6: Copy to final destination
echo -e "\nStep 6: Copying to final destination..."
rm -rf "$FINAL_OUTPUT"
cp -r "$WORK_DIR/translated" "$FINAL_OUTPUT"
echo "  Files copied to $FINAL_OUTPUT"

# Step 7: Verification
echo -e "\nStep 7: Verification..."
TRANSLATED_COUNT=$(find "$FINAL_OUTPUT" -type f -not -name "TRANSLATION_REPORT.md" | wc -l)
if [ "$TRANSLATED_COUNT" -eq "$FILE_COUNT" ]; then
    echo "  âœ“ All files translated successfully"
else
    echo "  âš  Warning: Expected $FILE_COUNT files, found $TRANSLATED_COUNT"
fi

echo -e "\n=== Pipeline Complete ==="
echo "Translated files are in: $FINAL_OUTPUT"
echo "Report available at: $FINAL_OUTPUT/TRANSLATION_REPORT.md"
</document_content>
</document>

<document index="32">
<source>examples/poem_en.txt</source>
<document_content>
# this_file: examples/poem_en.txt

Dawn spills over the rooftops,
Bells shimmer in the mist,
Neighbours trade their greetings,
And hope feels like a gift.

</document_content>
</document>

<document index="33">
<source>examples/poem_pl.txt</source>
<document_content>
# this_file: examples/poem_pl.txt

Åšwit spÅ‚ywa po dachach,
Dzwony lÅ›niÄ… w porannej mgle,
SÄ…siedzi wymieniajÄ… pozdrowienia,
A nadzieja znÃ³w czuje siÄ™ jak dar.

</document_content>
</document>

<document index="34">
<source>examples/translate.sh</source>
<document_content>
#!/bin/bash
# this_file: examples/translate.sh

# Basic shell script examples for abersetz CLI

# Example 1: Simple translation
echo "=== Example 1: Simple translation ==="
abersetz tr poem_en.txt --to-lang es --engine translators/google

# Example 2: Using shorthand command
echo -e "\n=== Example 2: Shorthand command ==="
abtr poem_en.txt --to-lang fr

# Example 3: Translate directory recursively
echo -e "\n=== Example 3: Directory translation ==="
abersetz tr ./docs --to-lang de --recurse --output ./docs_de

# Example 4: Translate with specific patterns
echo -e "\n=== Example 4: Pattern matching ==="
abtr . --include "*.md,*.txt" --exclude "*test*,.*" --to-lang ja --output ./translations/ja

# Example 5: Overwrite original files (be careful!)
echo -e "\n=== Example 5: In-place translation ==="
# abersetz tr backup_first.txt --to-lang es --overwrite

# Example 6: Dry run to test without translating
echo -e "\n=== Example 6: Dry run mode ==="
abersetz tr ./project --to-lang zh-CN --dry-run

# Example 7: Using different engines
echo -e "\n=== Example 7: Different engines ==="
# Google Translate
abtr file.txt --to-lang pt --engine translators/google

# Bing Translate
abtr file.txt --to-lang pt --engine translators/bing

# DeepL via deep-translator
abtr file.txt --to-lang pt --engine deep-translator/deepl

# Example 8: Save vocabulary for LLM engines
echo -e "\n=== Example 8: LLM with vocabulary ==="
# Requires SILICONFLOW_API_KEY environment variable
# abersetz tr technical.md --to-lang es --engine hysf --save-voc

# Example 9: Verbose mode for debugging
echo -e "\n=== Example 9: Verbose output ==="
abersetz tr test.txt --to-lang fr --verbose --dry-run

# Example 10: Check version
echo -e "\n=== Example 10: Version check ==="
abersetz version
</document_content>
</document>

<document index="35">
<source>examples/vocab.json</source>
<document_content>
{
  "this_file": "examples/vocab.json",
  "terms": {
    "rooftops": "dachy",
    "mist": "mgÅ‚a",
... (file content truncated to first 5 lines)
</document_content>
</document>

<document index="36">
<source>examples/walkthrough.md</source>
<document_content>
---
this_file: examples/walkthrough.md
---
# Sample Translation Walkthrough

```bash
abersetz translate examples/poem_en.txt \
  --to-lang pl \
  --engine hysf \
  --output examples/out \
  --save-voc \
  --verbose
```

The command writes the translated poem to `examples/out/poem_en.txt` and saves the evolving vocabulary as `examples/out/poem_en.txt.vocabulary.json`.

</document_content>
</document>

<document index="37">
<source>issues/102-review.md</source>
<document_content>
---
this_file: issues/102-review.md
---
# Codebase Review and Specification Compliance

**Issue:** #102
**Date:** 2025-09-20

## 1. Executive Summary

The `abersetz` codebase successfully implements the core requirements outlined in `SPEC.md`. The project is well-structured, follows modern Python practices, and demonstrates a clear understanding of the initial vision described in `IDEA.md`. The implementation is lean, focused, and effectively reuses established libraries, adhering to the project's philosophy.

The code is modular, with clear separation of concerns between configuration, translation engines, the translation pipeline, and the CLI. The use of `platformdirs` for configuration, `python-fire` for the CLI, and `semantic-text-splitter` for chunking aligns perfectly with the specification.

This review confirms that the current state of the codebase represents a solid Minimum Viable Product (MVP). The few deviations are minor and do not detract from the overall quality. The analysis below provides a detailed breakdown of compliance and offers minor suggestions for future refinement.

## 2. Specification Compliance Analysis

Here is a point-by-point comparison of the codebase against `SPEC.md`:

| Section | Specification Point | Compliance | Analysis & Comments |
| :--- | :--- | :--- | :--- |
| **2.1** | **File Handling** | âœ… **Full** | The `pipeline.py` module correctly handles file discovery, both for single files and directories. The `--recurse` flag is implemented in `cli.py` and passed to the pipeline. The `--overwrite` and `--output` flags are also correctly implemented. |
| **2.2** | **Translation Pipeline** | âœ… **Full** | The `pipeline.py` module implements the `locate -> chunk -> translate -> merge -> save` workflow as specified. The `translate_path` function orchestrates this process effectively. |
| **2.3** | **Content-Type Detection** | âœ… **Full** | `pipeline.py` includes a `_is_html` function that performs a basic but effective check for HTML tags, satisfying the requirement. |
| **3.1** | **Pre-integrated Engines** | âœ… **Full** | `engines.py` provides wrappers for `translators` and `deep-translator`. The engine selection logic correctly parses engine strings like `translators/google`. |
| **3.2.1** | **`hysf` Engine** | âœ… **Full** | The `HysfEngine` class in `engines.py` uses the `openai` client to interact with the specified Siliconflow endpoint. It correctly retrieves credentials from the configuration and uses `tenacity` for retries. |
| **3.2.2** | **`ullm` Engine** | âœ… **Full** | The `UllmEngine` in `engines.py` is highly configurable as specified. It supports profiles, custom prologs, and, most importantly, the `<output>` and `<vocabulary>` tag parsing logic. The vocabulary is correctly extracted and propagated to subsequent chunks. |
| **4.0** | **Configuration** | âœ… **Full** | `config.py` provides a robust configuration management system using `platformdirs`. It correctly handles storing and resolving credentials (both `env` and `value`). The schema matches the requirements, allowing for global defaults and engine-specific overrides. |
| **5.0** | **CLI** | âœ… **Full** | `cli.py` uses `python-fire` to expose the `translate` command with all the specified arguments. The CLI arguments are correctly wired to the `TranslatorOptions` dataclass. |
| **6.0** | **Python API** | âœ… **Full** | The `abersetz` package exposes `translate_path` and `TranslatorOptions` in its `__init__.py`, providing a clean and simple programmatic interface. |
| **7.0** | **Dependencies** | âœ… **Full** | The `pyproject.toml` and `DEPENDENCIES.md` files confirm that all specified dependencies are used correctly. |

## 3. Codebase Quality Analysis

### 3.1. Structure and Modularity

The project structure is excellent. The separation of concerns into distinct files (`config.py`, `engines.py`, `pipeline.py`, `cli.py`) makes the codebase easy to navigate and maintain. Each module has a clear responsibility:

-   `config.py`: Manages all configuration-related logic.
-   `chunking.py`: Handles text splitting.
-   `engines.py`: Abstracts the different translation services.
-   `pipeline.py`: Contains the core business logic of the translation process.
-   `cli.py`: Provides the command-line interface.

This modularity also contributes to the high testability of the code.

### 3.2. Code Quality and Style

-   **Clarity:** The code is well-written, with clear variable and function names.
-   **Typing:** The use of type hints is consistent and improves code readability and maintainability.
-   **Best Practices:** The project correctly uses modern Python features and libraries. The use of dataclasses for configuration objects is a good example.
-   **Dependencies:** The choice of dependencies is excellent. The project leverages high-quality, well-maintained libraries like `rich`, `loguru`, and `tenacity`, which aligns with the philosophy of not reinventing the wheel.

### 3.3. Testing

The project has a comprehensive test suite with high coverage (91% reported in `TESTING.md`). The tests are well-organized and cover the core functionality of each module. The use of a stub engine for pipeline tests is a particularly good practice, as it isolates the pipeline logic from network dependencies.

### 3.4. Documentation

The project is well-documented. The `README.md` is clear and provides a good overview of the project. The `PLAN.md`, `TODO.md`, and `CHANGELOG.md` files provide a good record of the project's history and future direction.

## 4. Conclusion and Recommendations

The `abersetz` project is a high-quality codebase that meets all the requirements of the initial specification. It is a well-designed, well-implemented, and well-tested piece of software.

**Recommendation:** The project is in an excellent state to be considered a complete MVP. No immediate changes are required. Future work can focus on the quality improvements listed in `TODO.md`, such as adding more robust error handling and expanding the integration test suite.

</document_content>
</document>

<document index="38">
<source>issues/103.txt</source>
<document_content>
The CLI tool is absurd: 

```
$ abersetz --help|cat
INFO: Showing help with the command 'abersetz -- --help'.

NAME
    abersetz - Fire-powered entrypoint.

SYNOPSIS
    abersetz -

DESCRIPTION
    Fire-powered entrypoint.
```

It doesnâ€™t expose any functionality. 

Re-read @IDEA.md and @SPEC.md and @PLAN.md and @TODO.md and the @llms.txt codebase and also @external/cerebrate-file.txt and @external/translators.txt and @external/semantic-text-splitter.txt and @external/python-ftfy.txt @external/platformdirs.txt and @dump_models 

Then into @PLAN.md and @TODO.md /plan the necessary changes. 

Then think hard and review and refine the @PLAN.md and @TODO.md 

Then /report and then finally /work on the tasks! 
</document_content>
</document>

<document index="39">
<source>package.toml</source>
<document_content>
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows 
</document_content>
</document>

<document index="40">
<source>pyproject.toml</source>
<document_content>
# this_file: pyproject.toml

[build-system]
requires = ["hatchling>=1.27", "hatch-vcs>=0.4"]
build-backend = "hatchling.build"

[project]
name = "abersetz"
description = ""
readme = "README.md"
requires-python = ">=3.10"
dynamic = ["version"]
dependencies = [
    "deep-translator>=1.11",
    "fire>=0.5",
    "loguru>=0.7",
    "openai>=1.51",
    "platformdirs>=4.3",
    "rich>=13.9",
    "semantic-text-splitter>=0.7",
    "tenacity>=8.4",
    "translators>=5.9",
    "tomli-w>=1.0",
    "tomli>=2.0; python_version < \"3.11\"",
]

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.license]
text = "MIT"

[project.urls]
Documentation = "https://github.com/twardoch/abersetz#readme"
Issues = "https://github.com/twardoch/abersetz/issues"
Source = "https://github.com/twardoch/abersetz"

[project.scripts]
abersetz = "abersetz.cli:main"
abtr = "abersetz.cli:abtr_main"

[dependency-groups]
dev = [
    "pytest>=8.3",
    "pytest-cov>=6.0",
    "ruff>=0.9",
    "mypy>=1.10",
]

[tool.hatch.version]
source = "vcs"

[tool.hatch.build]
exclude = ["/dist"]

[tool.hatch.build.targets.wheel]
packages = ["src/abersetz"]

[tool.hatch.build.hooks.vcs]
version-file = "src/abersetz/__about__.py"

[tool.hatch.envs.default]
python = "3.12"
dependencies = [
    "pytest>=8.3",
    "pytest-cov>=6.0",
    "ruff>=0.9",
    "mypy>=1.10",
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
lint = "ruff check {args:src tests}"
fmt = "ruff format {args:src tests}"
default = ["fmt", "lint", "test"]

[tool.uv]
default-groups = ["dev"]
python-preference = "managed"

[tool.ruff]
line-length = 100
target-version = "py310"

[tool.ruff.lint]
select = ["E", "F", "B", "I", "UP", "SIM"]
ignore = ["E203", "E501"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"

[tool.pytest.ini_options]
addopts = "-q"
testpaths = ["tests"]
markers = [
    "integration: mark test as integration test (requires network/API access)",
]

</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/__init__.py
# Language: python

from importlib import metadata as _metadata
from .pipeline import PipelineError, TranslationResult, TranslatorOptions, translate_path
from .__about__ import __version__


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/abersetz.py
# Language: python

from .pipeline import PipelineError, TranslationResult, TranslatorOptions, translate_path


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/chunking.py
# Language: python

import re
from collections.abc import Iterable
from enum import Enum
from semantic_text_splitter import TextSplitter

class TextFormat(E, n, u, m):
    """Minimal set of supported text formats."""

def detect_format((text: str)) -> TextFormat:
    """Detect whether ``text`` looks like HTML."""

def _fallback_chunks((text: str, max_size: int)) -> list[str]:
    """Simple slicing fallback when semantic splitter is unavailable."""

def _semantic_chunks((text: str, max_size: int)) -> Iterable[str]:
    """Prefer semantic-text-splitter when installed."""

def chunk_text((text: str, max_size: int, fmt: TextFormat)) -> list[str]:
    """Chunk text according to the detected format."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/cli.py
# Language: python

import json
import sys
from collections.abc import Iterable, Sequence
from pathlib import Path
import fire
from loguru import logger
from rich.console import Console
from .config import config_path, load_config
from .pipeline import PipelineError, TranslationResult, TranslatorOptions, translate_path
from . import __version__

class ConfigCommands:
    """Configuration related helpers."""
    def show((self)) -> dict[str, object]:
    def path((self)) -> str:

class AbersetzCLI:
    """Abersetz translation tool - translate files between languages."""
    def version((self)) -> str:
        """Show version information."""
    def tr((
        self,
        to_lang: str,
        path: str | Path,
        *,
        engine: str | None = None,
        from_lang: str | None = None,
        recurse: bool = True,
        overwrite: bool = False,
        output: str | Path | None = None,
        save_voc: bool = False,
        chunk_size: int | None = None,
        html_chunk_size: int | None = None,
        include: str | Sequence[str] | None = None,
        exclude: str | Sequence[str] | None = None,
        dry_run: bool = False,
        prolog: str | None = None,
        vocabulary: str | None = None,
        verbose: bool = False,
    )) -> None:
    def config((self)) -> ConfigCommands:

def _configure_logging((verbose: bool)) -> None:

def _parse_patterns((value: str | Sequence[str] | None)) -> tuple[str, ...]:

def _load_json_data((reference: str | None)) -> dict[str, str]:

def _render_results((results: Iterable[TranslationResult])) -> None:

def show((self)) -> dict[str, object]:

def path((self)) -> str:

def _validate_language_code((code: str | None, param_name: str)) -> str | None:
    """Validate language code format."""

def _build_options_from_cli((
    to_lang: str,
    path: str | Path,
    *,
    engine: str | None,
    from_lang: str | None,
    recurse: bool,
    overwrite: bool,
    output: str | None,
    save_voc: bool,
    chunk_size: int | None,
    html_chunk_size: int | None,
    include: str | Sequence[str] | None,
    exclude: str | Sequence[str] | None,
    dry_run: bool,
    prolog: str | None,
    vocabulary: str | None,
)) -> TranslatorOptions:

def version((self)) -> str:
    """Show version information."""

def tr((
        self,
        to_lang: str,
        path: str | Path,
        *,
        engine: str | None = None,
        from_lang: str | None = None,
        recurse: bool = True,
        overwrite: bool = False,
        output: str | Path | None = None,
        save_voc: bool = False,
        chunk_size: int | None = None,
        html_chunk_size: int | None = None,
        include: str | Sequence[str] | None = None,
        exclude: str | Sequence[str] | None = None,
        dry_run: bool = False,
        prolog: str | None = None,
        vocabulary: str | None = None,
        verbose: bool = False,
    )) -> None:

def config((self)) -> ConfigCommands:

def main(()) -> None:
    """Invoke the Fire CLI."""

def abtr_main(()) -> None:
    """Direct translation CLI - equivalent to 'abersetz tr'."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/config.py
# Language: python

import copy
import json
import os
from collections.abc import Mapping
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any
from platformdirs import user_config_dir
import tomllib
import tomli as tomllib
import tomli_w
from loguru import logger
from loguru import logger

class Defaults:
    """Runtime defaults for translation."""
    def to_dict((self)) -> dict[str, Any]:

class Credential:
    """Represents an API credential reference."""
    def to_dict((self)) -> dict[str, str]:

class EngineConfig:
    """Engine specific configuration block."""
    def to_dict((self)) -> dict[str, Any]:

class AbersetzConfig:
    """Aggregate configuration for the toolkit."""
    def to_dict((self)) -> dict[str, Any]:

def to_dict((self)) -> dict[str, Any]:

def from_dict((cls, raw: Mapping[str, Any] | None)) -> Defaults:

def to_dict((self)) -> dict[str, str]:

def from_any((cls, raw: CredentialLike | None)) -> Credential | None:

def to_dict((self)) -> dict[str, Any]:

def from_dict((cls, name: str, raw: Mapping[str, Any] | None)) -> EngineConfig:

def to_dict((self)) -> dict[str, Any]:

def from_dict((cls, raw: Mapping[str, Any])) -> AbersetzConfig:

def _default_dict(()) -> dict[str, Any]:
    """Return a deep copy of the default config mapping."""

def _default_config(()) -> AbersetzConfig:
    """Return a fresh ``AbersetzConfig`` with defaults."""

def config_dir(()) -> Path:
    """Return directory holding the configuration file."""

def config_path(()) -> Path:
    """Return absolute path to the configuration file."""

def load_config(()) -> AbersetzConfig:
    """Load configuration from disk, creating defaults if needed."""

def save_config((config: AbersetzConfig)) -> None:
    """Persist configuration to ``config.toml``."""

def resolve_credential((
    config: AbersetzConfig,
    reference: CredentialLike,
)) -> str | None:
    """Resolve a credential reference to a usable secret."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/engines.py
# Language: python

import json
import re
from collections.abc import Callable, Mapping
from dataclasses import dataclass
from typing import Any, Protocol
import translators
from deep_translator import (  # type: ignore
    DeeplTranslator,
    GoogleTranslator,
    LibreTranslator,
    LingueeTranslator,
    MicrosoftTranslator,
    MyMemoryTranslator,
    PapagoTranslator,
)
from openai import OpenAI
from tenacity import retry, stop_after_attempt, wait_exponential
from .chunking import TextFormat
from .config import AbersetzConfig, EngineConfig, resolve_credential

class EngineError(R, u, n, t, i, m, e, E, r, r, o, r):
    """Raised when an engine cannot be constructed or invoked."""

class EngineRequest:
    """Payload passed to engines."""

class EngineResult:
    """Normalized engine output."""

class Engine(P, r, o, t, o, c, o, l):
    """Protocol implemented by engine adapters."""
    def translate((self, request: EngineRequest)) -> EngineResult:
        """Translate a chunk."""
    def chunk_size_for((self, fmt: TextFormat)) -> int | None:
        """Return preferred chunk size for the given text format."""

class EngineBase:
    """Shared helpers for engines."""
    def __init__((
        self,
        name: str,
        chunk_size: int | None,
        html_chunk_size: int | None,
    )) -> None:
    def chunk_size_for((self, fmt: TextFormat)) -> int | None:

class TranslatorsEngine(E, n, g, i, n, e, B, a, s, e):
    """Wrapper around the `translators` package with retry logic."""
    def __init__((self, provider: str, config: EngineConfig)) -> None:
    def translate((self, request: EngineRequest)) -> EngineResult:

class DeepTranslatorEngine(E, n, g, i, n, e, B, a, s, e):
    """Adapter for `deep-translator` providers with retry logic."""
    def __init__((self, provider: str, config: EngineConfig)) -> None:
    def translate((self, request: EngineRequest)) -> EngineResult:

class LlmEngine(E, n, g, i, n, e, B, a, s, e):
    """Shared logic for LLM backed engines."""
    def __init__((
        self,
        config: EngineConfig,
        client: Any,
        *,
        model: str,
        temperature: float,
        static_prolog: Mapping[str, str] | None = None,
    )) -> None:
    def translate((self, request: EngineRequest)) -> EngineResult:
    def _build_messages((
        self,
        request: EngineRequest,
        vocabulary: Mapping[str, str],
        merged: Mapping[str, str],
    )) -> list[dict[str, str]]:
    def _parse_payload((self, payload: str)) -> tuple[str, dict[str, str]]:

def translate((self, request: EngineRequest)) -> EngineResult:
    """Translate a chunk."""

def chunk_size_for((self, fmt: TextFormat)) -> int | None:
    """Return preferred chunk size for the given text format."""

def __init__((
        self,
        name: str,
        chunk_size: int | None,
        html_chunk_size: int | None,
    )) -> None:

def chunk_size_for((self, fmt: TextFormat)) -> int | None:

def __init__((self, provider: str, config: EngineConfig)) -> None:

def _translate_with_retry((
        self, text: str, is_html: bool, source_lang: str, target_lang: str
    )) -> str:
    """Internal method with retry logic for network failures."""

def translate((self, request: EngineRequest)) -> EngineResult:

def __init__((self, provider: str, config: EngineConfig)) -> None:

def _translate_with_retry((self, text: str, source_lang: str, target_lang: str)) -> str:
    """Internal method with retry logic for network failures."""

def translate((self, request: EngineRequest)) -> EngineResult:

def __init__((
        self,
        config: EngineConfig,
        client: Any,
        *,
        model: str,
        temperature: float,
        static_prolog: Mapping[str, str] | None = None,
    )) -> None:

def _invoke((self, messages: list[dict[str, str]])) -> str:

def translate((self, request: EngineRequest)) -> EngineResult:

def _build_messages((
        self,
        request: EngineRequest,
        vocabulary: Mapping[str, str],
        merged: Mapping[str, str],
    )) -> list[dict[str, str]]:

def _parse_payload((self, payload: str)) -> tuple[str, dict[str, str]]:

def _make_openai_client((token: str, base_url: str | None)) -> OpenAI:
    """Create an OpenAI client respecting optional base URL."""

def _build_llm_engine((
    selector: str,
    config: AbersetzConfig,
    engine_cfg: EngineConfig,
    *,
    profile: Mapping[str, Any] | None,
    client: Any | None,
)) -> Engine:

def _translators_provider((variant: str | None, engine_cfg: EngineConfig)) -> str:

def _select_profile((engine_cfg: EngineConfig, variant: str | None)) -> Mapping[str, Any] | None:

def create_engine((
    selector: str,
    config: AbersetzConfig,
    *,
    client: Any | None = None,
)) -> Engine:
    """Factory that builds the requested engine."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/src/abersetz/pipeline.py
# Language: python

import json
from collections.abc import Iterable
from dataclasses import dataclass, field
from pathlib import Path
from .chunking import TextFormat, chunk_text, detect_format
from .config import AbersetzConfig, load_config
from .engines import Engine, EngineRequest, EngineResult, create_engine

class TranslatorOptions:
    """Runtime options controlling translation behaviour."""

class TranslationResult:
    """Information about a translated artefact."""

class PipelineError(R, u, n, t, i, m, e, E, r, r, o, r):
    """Raised when translation cannot proceed."""

def translate_path((
    path: Path | str,
    options: TranslatorOptions | None = None,
    *,
    config: AbersetzConfig | None = None,
    client: object | None = None,
)) -> list[TranslationResult]:
    """Translate a file or directory tree."""

def _merge_defaults((options: TranslatorOptions | None, config: AbersetzConfig)) -> TranslatorOptions:

def _discover_files((root: Path, opts: TranslatorOptions)) -> Iterable[Path]:

def _is_excluded((path: Path, patterns: tuple[str, ...])) -> bool:

def _translate_file((
    source: Path,
    engine: Engine,
    opts: TranslatorOptions,
    config: AbersetzConfig,
)) -> TranslationResult:

def _apply_engine((
    engine: Engine,
    chunks: Iterable[str],
    fmt: TextFormat,
    opts: TranslatorOptions,
    config: AbersetzConfig,
)) -> tuple[list[EngineResult], dict[str, str]]:

def _build_request((
    chunk: str,
    index: int,
    total: int,
    fmt: TextFormat,
    opts: TranslatorOptions,
    config: AbersetzConfig,
    vocabulary: dict[str, str],
    prolog: dict[str, str],
)) -> EngineRequest:

def _select_chunk_size((
    fmt: TextFormat,
    engine: Engine,
    opts: TranslatorOptions,
    config: AbersetzConfig,
)) -> int:

def _persist_output((
    source: Path,
    content: str,
    vocabulary: dict[str, str],
    fmt: TextFormat,
    opts: TranslatorOptions,
    target_lang: str,
)) -> Path:


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/conftest.py
# Language: python

import sys
from pathlib import Path
import pytest

def _temp_config_dir((tmp_path: Path, monkeypatch: pytest.MonkeyPatch)) -> Path:
    """Isolate persisted config for each test run."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_chunking.py
# Language: python

from abersetz.chunking import TextFormat, chunk_text, detect_format

def test_detect_format_identifies_html(()) -> None:

def test_chunk_text_preserves_round_trip(()) -> None:

def test_html_chunking_returns_single_chunk(()) -> None:


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_cli.py
# Language: python

from pathlib import Path
import pytest
from abersetz.cli import AbersetzCLI
from abersetz.pipeline import TranslatorOptions

def test_cli_translate_wires_arguments((monkeypatch: pytest.MonkeyPatch, tmp_path: Path)) -> None:

def fake_translate_path((path: str, options: TranslatorOptions)):

def test_cli_config_path_outputs((monkeypatch: pytest.MonkeyPatch)) -> None:


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_config.py
# Language: python

import json
from pathlib import Path
import pytest
import abersetz.config as config_module
import tomllib
import tomli as tomllib
import platform

def test_load_config_yields_defaults((tmp_path: Path)) -> None:

def test_save_config_persists_changes((tmp_path: Path)) -> None:

def test_resolve_credential_prefers_environment((monkeypatch: pytest.MonkeyPatch)) -> None:

def test_load_config_handles_malformed_toml((
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
)) -> None:
    """Test that malformed TOML config files are handled gracefully."""

def test_load_config_converts_legacy_json((tmp_path: Path, monkeypatch: pytest.MonkeyPatch)) -> None:
    """Ensure legacy JSON configs are migrated to TOML."""

def test_load_config_handles_permission_error((
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
)) -> None:
    """Test that permission errors are handled gracefully."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_engines.py
# Language: python

from types import SimpleNamespace
import pytest
import abersetz.config as config_module
from abersetz.engines import EngineRequest, create_engine
from abersetz.engines import DeepTranslatorEngine

class DummyClient:
    """Simple stub mimicking OpenAI chat completions."""
    def __init__((self, payload: str)):
    def _create((self, **kwargs: object)) -> SimpleNamespace:

class MockTranslator:
    def __init__((self, source: str, target: str)):
    def translate((self, text: str)) -> str:

def __init__((self, payload: str)):

def _create((self, **kwargs: object)) -> SimpleNamespace:

def test_translators_engine_invokes_library((monkeypatch: pytest.MonkeyPatch)) -> None:

def fake_translate_text((
        text: str, translator: str, from_language: str, to_language: str, **_: object
    )) -> str:

def test_hysf_engine_parses_vocabulary((monkeypatch: pytest.MonkeyPatch)) -> None:

def test_ullm_engine_uses_profile((monkeypatch: pytest.MonkeyPatch)) -> None:

def test_translators_engine_retry_on_failure((monkeypatch: pytest.MonkeyPatch)) -> None:
    """Test that TranslatorsEngine retries on network failures."""

def fake_translate_with_retry((
        text: str, translator: str, from_language: str, to_language: str, **_: object
    )) -> str:

def test_deep_translator_engine_retry_on_failure((monkeypatch: pytest.MonkeyPatch)) -> None:
    """Test that DeepTranslatorEngine retries on network failures."""

def __init__((self, source: str, target: str)):

def translate((self, text: str)) -> str:


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_integration.py
# Language: python

import os
import pytest
from abersetz import TranslatorOptions, translate_path
from abersetz.config import load_config
from abersetz.engines import EngineRequest, create_engine
from unittest.mock import patch
import requests

def test_translators_google_real(()) -> None:
    """Test Google Translate via translators library (requires network)."""

def test_deep_translator_google_real(()) -> None:
    """Test Google Translate via deep-translator library (requires network)."""

def test_hysf_engine_real(()) -> None:
    """Test Siliconflow translation engine (requires API key)."""

def test_translate_file_api((tmp_path)) -> None:
    """Test the high-level translate_path API."""

def test_html_translation(()) -> None:
    """Test HTML content translation preserves markup."""

def test_translators_bing_real(()) -> None:
    """Test Bing Translate via translators library (requires network)."""

def test_batch_translation_with_vocabulary(()) -> None:
    """Test translating multiple chunks with vocabulary propagation."""

def test_retry_on_network_failure(()) -> None:
    """Test that retry mechanism works for real network issues."""

def flaky_get((*args, **kwargs)):


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_package.py
# Language: python

import abersetz

def test_version(()) -> None:
    """Verify package exposes version."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/abersetz/tests/test_pipeline.py
# Language: python

from pathlib import Path
import pytest
from abersetz.engines import EngineResult
from abersetz.pipeline import PipelineError, TranslatorOptions, translate_path

class DummyEngine:
    """Minimal engine used for pipeline tests."""
    def __init__((self)) -> None:
    def chunk_size_for((self, _fmt)) -> int:
    def translate((self, request)) -> EngineResult:

def __init__((self)) -> None:

def chunk_size_for((self, _fmt)) -> int:

def translate((self, request)) -> EngineResult:

def test_translate_path_processes_files((tmp_path: Path, monkeypatch: pytest.MonkeyPatch)) -> None:

def test_translate_path_requires_matches((tmp_path: Path)) -> None:


</documents>